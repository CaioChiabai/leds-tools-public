{"searchDocs":[{"title":"Instalation","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/installation","content":"Instalation To install Ands, follow these steps: Open Visual Studio CodeClick on ExtensionsSearch for Andes LEDSClick to install the ANDES extension by LEDS IFES","keywords":"","version":"Next"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/faq","content":"Frequently Asked Questions to do !","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/overview","content":"","keywords":"","version":"Next"},{"title":"Features:​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/andes/overview#features","content":" Create a Markdon Documentation with Software Requirements, User Case and Actores.End-to-End Test Case using Gherkin grammar.Made`s document to support management process.Spark`s document to support Development process. ","version":"Next","tagName":"h2"},{"title":"How to Use","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/howtouse","content":"How to Use Create a file with extension .andes (e.g., slave_one.spark)Define the class diagramSave the file .andesClick with right botton and chose one optionAfter that, Andes will generate the software artifacts","keywords":"","version":"Next"},{"title":"VS Code Extension – leds-tools-made","type":0,"sectionRef":"#","url":"/leds-tools-public/made/Architecture/leds-tools-made","content":"","keywords":"","version":"Next"},{"title":"Purpose​","type":1,"pageTitle":"VS Code Extension – leds-tools-made","url":"/leds-tools-public/made/Architecture/leds-tools-made#purpose","content":" Core plugin that lets users define projects and agile data through a custom DSL (.made files). It interprets those files, manages data via modular applications, and can generate documentation via integration with made-lib.  ","version":"Next","tagName":"h2"},{"title":"Main Components​","type":1,"pageTitle":"VS Code Extension – leds-tools-made","url":"/leds-tools-public/made/Architecture/leds-tools-made#main-components","content":" ","version":"Next","tagName":"h2"},{"title":"Applications​","type":1,"pageTitle":"VS Code Extension – leds-tools-made","url":"/leds-tools-public/made/Architecture/leds-tools-made#applications","content":" Located in application/. Each handles a domain like Project, Team, TimeBox, Backlog, etc.  ","version":"Next","tagName":"h3"},{"title":"Langium DSL Integration​","type":1,"pageTitle":"VS Code Extension – leds-tools-made","url":"/leds-tools-public/made/Architecture/leds-tools-made#langium-dsl-integration","content":" Found in language/, defining the grammar for .made files, scope resolution, and linking.  ","version":"Next","tagName":"h3"},{"title":"Report Generation​","type":1,"pageTitle":"VS Code Extension – leds-tools-made","url":"/leds-tools-public/made/Architecture/leds-tools-made#report-generation","content":" Integrated with made-lib to output markdown, charts, and documentation.  ","version":"Next","tagName":"h3"},{"title":"Key Directories​","type":1,"pageTitle":"VS Code Extension – leds-tools-made","url":"/leds-tools-public/made/Architecture/leds-tools-made#key-directories","content":" application/ # Project, Team, TimeBox, Issue, Backlog, etc. language/ # Langium grammar and generated parser static/ # Monaco Editor UI files example/ # Sample .made files  ","version":"Next","tagName":"h2"},{"title":"Metamodel","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/metamodel","content":"","keywords":"","version":"Next"},{"title":"Model​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#model","content":" Description: The Model serves as the entry point of the grammar. It encapsulates the overall project structure by containing multiple Project, Requirements, and UseCase instances.Attributes: projects: A collection of Project instances associated with the model.requirements: A collection of Requirements instances defining the system's requirements.useCases: A collection of UseCase instances representing the system's use cases. Relationships: Contains: Multiple Project instances.Multiple Requirements instances.Multiple UseCase instances.  ","version":"Next","tagName":"h2"},{"title":"Project​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#project","content":" Description: Represents a project within the model, providing an overview and specific details about the project's purpose and scope.Attributes: id: A unique identifier for the project.name: The name of the project.description: A detailed description of the project.purpose: The primary purpose of the project.miniworld: A string describing the project's mini-world or domain context. Relationships: Contained By: Belongs to one Model.  ","version":"Next","tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#requirements","content":" Description: Encapsulates the system's requirements, categorizing them into functional and non-functional types.Attributes: id: A unique identifier for the requirements section.name: The name of the requirements section.description: A description outlining the scope of the requirements.requirements: A collection of Requirement instances detailing individual requirements. Relationships: Contains: Multiple Requirement instances.  ","version":"Next","tagName":"h2"},{"title":"Requirement (Abstract Class)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#requirement-abstract-class","content":" Description: An abstract representation of a system requirement. Serves as a base for more specific requirement types.Attributes: name: The name of the requirement.description: A detailed description of the requirement. Inheritance: FunctionalRequirement and NonFunctionalRequirement inherit from Requirement.  ","version":"Next","tagName":"h2"},{"title":"FunctionalRequirement​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#functionalrequirement","content":" Description: Represents a functional requirement detailing specific behaviors or functions the system must perform.Inheritance: Inherits from Requirement.  ","version":"Next","tagName":"h2"},{"title":"NonFunctionalRequirement​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#nonfunctionalrequirement","content":" Description: Represents a non-functional requirement specifying system attributes such as performance, security, or usability.Inheritance: Inherits from Requirement.  ","version":"Next","tagName":"h2"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#usecase","content":" Description: Represents a use case within the system, defining a specific functionality or behavior that actors can perform.Attributes: name: A QualifiedName that uniquely identifies the use case.fullName: A string representing the full name of the use case.kind: An enumeration (Kind) indicating the type of use case (manage or view).performedActors: A collection of Actor instances that perform this use case.involvedEntities: A collection of Entity instances involved in this use case.extendsUseCases: A collection of UseCase instances that this use case extends.includesUseCases: A collection of UseCase instances that this use case includes. Relationships: Performed By: Multiple Actor instances. Involves: Multiple Entity instances. Extends: Can extend multiple UseCase instances. Includes: Can include multiple UseCase instances.  ","version":"Next","tagName":"h2"},{"title":"Actor​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/andes/metamodel#actor","content":" Description: Represents an actor within the system, typically a user or external system that interacts with use cases.Attributes: name: A QualifiedName that uniquely identifies the actor.entity: An Entity that the actor is associated with.superType: An optional reference to another Actor that this actor extends. Relationships: Extends: An Actor can optionally extend another Actor, establishing an inheritance relationship.Implements: Implements the Entity interface. ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/andes/project_managment#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tCreate Analysis Document\tCreate an analysis document in Markdown with the following information: Requirements, Use Cases, Class Diagram, and State Diagram, to be published on Docusaurus.\t100\tImprove Comunication betwen teams in 10% 2\tDependency Analysis\tUpdate the analysis document with a section for dependencies between use cases and events.\t90\tImprove project management in 15% 3\tModule Planning\tCreate a planning document in the Made format, based on use cases.\t80\tImprove project management in 5% 4\tUpdate Planning with Tasks\tUpdate the planning document with tasks for each event, based on the development process.\t82\tImprove project management in 10% 5\tCreate Development Artifacts\tCreate a Spark-type document, using the data from the analysis.\t70\tImprove developing process int in 10%  ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/andes/project_managment#general-planning","content":" Release 1.0 - (14/10/2024 - 01/11/2024): create a documentation using Software Requirement information.Release 2.0 - (04/11/2024 - 31/11/2024): create a Made and Spark documents  ","version":"Next","tagName":"h2"},{"title":"Release 1.0 - 01/11/2024​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/andes/project_managment#release-10---01112024","content":" Goal: Create an analysis document in Markdown with the following information: Requirements, Use Cases, Class Diagram, and State Diagram, to be published on Docusaurus and Update the analysis document with a section for dependencies between use cases and events. . Features: ID 1 and ID 2 Deadline I - 25/10/2024 ID 1: Create an analysis document in Markdown with the following information: Requirements, Use Cases, Class Diagram, and State Diagram, to be published on Docusaurus Deadline II - 01/11/2024 ID 2: Update the analysis document with a section for dependencies between use cases and events.  ","version":"Next","tagName":"h2"},{"title":"Code Wise","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/#overview","content":" Once installed and configured, CodeWise operates silently in the background. It monitors your Git repository for new commits and automatically triggers a set of intelligent agents that review the code changes, offering structured, insightful feedback saved directly into your workspace.  Install the extension locally Configure your .env file with the appropriate LLM credentials: (name of your provider)_API_KEY=your-api-key (ex. GEMINI_API_KEY) MODEL=your-model-name PROVIDER=gemini Supported providers: openai google (Gemini) groq ollama mistral cohere anthropic together Ensure your project has the necessary dependencies: &quot;@types/node&quot;: &quot;20.x&quot;&quot;typescript&quot;: &quot;^5.8.3&quot;&quot;node.js&quot;: &quot;^v20.18.0&quot;&quot;npm&quot;: &quot;^11.4.1&quot;Visual Studio Code (v1.85+)  ","version":"Next","tagName":"h3"},{"title":"How to Use​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/#how-to-use","content":" This action runs automatically on every commit. It analyzes code files changed in the commit and sends a file (commit_analysis_report.md) with analysis about performance and code smell suggestions to the root of projects.  ","version":"Next","tagName":"h3"},{"title":"Workflow Breakdown​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/#workflow-breakdown","content":" The following steps describe the internal process behind CodeWise:  Git Commit Detection CodeWise watches the .git/logs/HEAD file to detect when a new commit is made. This enables real-time, non-intrusive monitoring of commit activity without requiring Git hooks. Extract Commit Information Once a commit is detected, the system extracts: Commit hash, author, date, and messageChanged files and corresponding diffs This information is formatted and saved in a temporary file (gitInput.txt) to serve as input for the language models. Invoke LLM Agents in Parallel CodeWise leverages a set of specialized agents (built on top of LangChain + LangGraph), each trained to analyze a specific dimension of the codebase: Architect Agent: Analyzes folder structure and determines the architectural pattern used (e.g., MVC, Clean Architecture).Integration Agent: Reviews module coupling and suggests integration improvements.SOLID Agent: Detects violations of SOLID principles and proposes corrections.Framework Analyst: Suggests alternative frameworks or improvements in the usage of existing ones.Design Pattern Advisor: Recommends design patterns suitable for scalability, reusability, or maintainability. Merge Results into Markdown Report The results from all LLMs are aggregated into a structured markdown report (commit_analysis_report.md), which includes individual sections for each agent’s findings. Clean Up and Await Next Commit After the report is generated, temporary files are deleted and the extension continues monitoring for future commits.  This automated cycle ensures that every commit is reviewed by AI before it even reaches the remote repository — enabling proactive quality control and faster feedback for developers.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/#features","content":" Pre-commit Code Analysis Automatically analyzes code right after a local commit is made, ensuring issues are caught before pushing to the repository. LLM-Based Multi-Agent Architecture Utilizes multiple specialized Language Model agents (Architect, Integration Analyst, SOLID Reviewer, Design Pattern Advisor, etc.) working in parallel for deep, context-aware code evaluation. Support for Multiple LLM Providers Compatible with various LLM providers (OpenAI, Google Gemini, Ollama, Mistral, Groq, Cohere, and more) with plug-and-play extensibility via a factory pattern and reflection-based dynamic loading. Automatic Report Generation Produces a detailed markdown report (commit_analysis_report.md) after each commit, summarizing architectural insights, design flaws, and suggestions. No User Disruption Fully background operation – developers commit code as usual while CodeWise silently processes and reports. Multi-language Project Support Can analyze projects written in multiple programming languages, especially those structured around standard architectural patterns (e.g., MVC, DDD). Cross-Platform Compatibility Designed to work on Windows, macOS, and Linux environments (as long as Node.js and VS Code are installed). Modular and Extensible Design Easy to extend with new agent roles, models, or analysis types using a clean and maintainable architecture. CI/CD Ready CodeWise is built to support packaging and publishing via GitHub Actions, enabling streamlined deployment of new versions.  ","version":"Next","tagName":"h3"},{"title":"Requirements​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/#requirements","content":" &quot;@types/node&quot;: &quot;20.x&quot; &quot;typescript&quot;: &quot;^5.8.3&quot; &quot;node.js&quot;: &quot;^v20.18.0&quot; &quot;npm&quot;: &quot;^11.4.1&quot; Visual Studio Code (v1.85+)  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Code Wise","url":"/leds-tools-public/code_wise/#usage","content":" Once installed and activated, CodeWise automatically monitors your Git workspace for new commits. When a commit is made, the extension triggers a background process that analyzes the committed code and generates a comprehensive report with architectural insights and improvement suggestions.  Follow these steps to use CodeWise:  Open a Git-based project in VS Code. Ensure the project is tracked by Git and has at least one workspace folder opened. Make a commit. When you commit code, CodeWise detects the change and analyzes it automatically. Wait for the analysis. Within seconds, CodeWise runs a set of LLM agents to analyze your code based on architecture, integration, design patterns, SOLID principles, and framework usage. Check the output report. A new file named commit_analysis_report.md will be created in the root of your project, containing a detailed summary of findings and suggestions. Review and refactor. Open the report to review the suggestions. Use the insights to refactor and improve your code quality before pushing to remote repositories.  The process is fully automated and non-intrusive. Developers commit code as usual; CodeWise works silently in the background. ","version":"Next","tagName":"h3"},{"title":"Dockerized Runtime – leds-tools-made-docker","type":0,"sectionRef":"#","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker","content":"","keywords":"","version":"Next"},{"title":"Purpose​","type":1,"pageTitle":"Dockerized Runtime – leds-tools-made-docker","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker#purpose","content":" Provides a containerized environment to run MADE report generation from JSON or DSL data using the made-lib.  ","version":"Next","tagName":"h2"},{"title":"Main Components​","type":1,"pageTitle":"Dockerized Runtime – leds-tools-made-docker","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker#main-components","content":" ","version":"Next","tagName":"h2"},{"title":"Docker/Compose Setup​","type":1,"pageTitle":"Dockerized Runtime – leds-tools-made-docker","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker#dockercompose-setup","content":" Dockerfile to run the Node.js environment with made-lib.docker-compose.yml for local dev/testing.  ","version":"Next","tagName":"h3"},{"title":"Directory Mapping​","type":1,"pageTitle":"Dockerized Runtime – leds-tools-made-docker","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker#directory-mapping","content":" /app/config: Configuration files like directories.json./host: Where .made or .json data is read.  ","version":"Next","tagName":"h3"},{"title":"Source Code​","type":1,"pageTitle":"Dockerized Runtime – leds-tools-made-docker","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker#source-code","content":" src/index.ts: Entrypoint CLI logicsrc/index.test.ts: Unit tests  ","version":"Next","tagName":"h3"},{"title":"Documentation Assets​","type":1,"pageTitle":"Dockerized Runtime – leds-tools-made-docker","url":"/leds-tools-public/made/Architecture/leds-tools-made-docker#documentation-assets","content":" example_1/sprints/sprint1.md: Sprint reports02_backlogs.md, 03_roadmap.md: Project documentation ","version":"Next","tagName":"h3"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/code_wise/project_managment","content":"","keywords":"","version":"Next"},{"title":"Project Model Canvas (PMC)​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#project-model-canvas-pmc","content":" ","version":"Next","tagName":"h2"},{"title":"Justification​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#justification","content":" Software developers face slow manual feedback cycles, difficulty identifying performance issues, accumulated technical debt, and a lack of reliable indicators to support code quality improvements.  ","version":"Next","tagName":"h3"},{"title":"SMART Objective​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#smart-objective","content":" Develop and launch the CodeWise API within 3 months, with an 8-person team, to increase productivity and delivery quality by providing automated feedback and statistical insights.  ","version":"Next","tagName":"h3"},{"title":"Final Product​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#final-product","content":" An API developed using FastAPI, integrated with OpenAI GPT-3 to analyze code in Python, C#, and Java. The API provides documented endpoints (Swagger/OpenAPI), real-time consultations, and performance and quality reports.  ","version":"Next","tagName":"h3"},{"title":"Benefits​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#benefits","content":" Automated code review generationReliable statistics on technical debtProven quality improvement in deliveries, supported by literature and team dataDirect impact on developer productivity  ","version":"Next","tagName":"h3"},{"title":"Requirements​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#requirements","content":" FastAPI and Python 3.xIntegration with the OpenAI GPT-3 APISupport for analyzing code in Python, C#, and JavaDocker containerizationSecure management of access keys and data  ","version":"Next","tagName":"h3"},{"title":"External Stakeholders and Influencing Factors​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#external-stakeholders-and-influencing-factors","content":" Developers at LEDSDevelopers and companies seeking to improve code qualityOpen source communities and tech forums  ","version":"Next","tagName":"h3"},{"title":"Premises​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#premises","content":" The development team has knowledge of Python and FastAPIThe project management team is familiar with delivery monitoring tools  ","version":"Next","tagName":"h3"},{"title":"Constraints​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#constraints","content":" OpenAI API limitations (rate limits and code size)Strict security requirements for API keys and access credentialsBudget and delivery deadline limited to 3 months  ","version":"Next","tagName":"h3"},{"title":"Risks​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#risks","content":" External Dependency: Reliance on the OpenAI API (risk of rate limits or downtime)Feedback Accuracy: Possibility of imprecise suggestions from GPT-3Probability: Moderate, due to integration complexity and request volumeMitigation Actions: Continuous monitoring, robust testing, fallback plans; acceptance of potential limitations  ","version":"Next","tagName":"h3"},{"title":"Team​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#team","content":" Project Management (GPS students): Planning, monitoring, coordination, and communicationDevelopment (Systems Project students): Coding, testing, deployment, and documentation  ","version":"Next","tagName":"h3"},{"title":"Cost Estimate​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#cost-estimate","content":" Team Load: 8 people × 8 hours/week = 64 hours/weekRate per Hour (Pleno Developer avg.): R$ 80/hourEstimated Weekly Cost: 64 × R$ 80 = R$ 5,120Estimated Total over 12 Weeks: R$ 61,440  ","version":"Next","tagName":"h3"},{"title":"Team Topology​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#team-topology","content":" This project follows a Platform Team model. The CodeWise team provides internal services and tools to Stream-Aligned Teams (e.g., the IT development teams), who deliver value directly to end users. CodeWise supports them by enhancing the quality and efficiency of their code through automated analysis.  ","version":"Next","tagName":"h3"},{"title":"Deliverables​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#deliverables","content":"   Code Analysis Module – Rule-based code validation with Gemini API.Platform Integration – GitHub Webhooks, Discord alerts via n8n.Feedback Engine – Smart improvement suggestions with clean formatting.Metrics Dashboard – PR scores, activity history, developer stats.  ","version":"Next","tagName":"h3"},{"title":"Timeline​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#timeline","content":"   Month 1: Planning, prototyping, Gemini integrationMonth 2: Core development, GitHub/Discord integration, testingMonth 3: Dashboard, final testing, documentation, beta release  ","version":"Next","tagName":"h3"},{"title":"Team Topology​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#team-topology-1","content":" Our team follows the Platform Team topology model.  The CodeWise project is being developed by a platform team composed of the following members:  ","version":"Next","tagName":"h2"},{"title":"📌 Platform Team – CodeWise Project​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#-platform-team--codewise-project","content":" Project Management​  Perceu OliveiraMiguel MaliniJoão FerrareisWal Candeia  Systems and Development​  Arthur MiguelMichele AltavillaBernardo RosaGabriel Brito    The CodeWise project is being developed by a platform team because our main customer is an internal client — specifically, the software development teams within the IT department. These internal teams are responsible for delivering direct value to end users and are aligned with the Stream-Aligned Team topology.  In this context, CodeWise serves as a support tool that enhances the efficiency and quality of the code produced by stream-aligned teams. It operates by analyzing already-written code and offering suggestions for improvements, thus contributing indirectly to the final value delivery.  This separation allows the Platform Team (CodeWise team) to focus on building and maintaining a reusable service that empowers and accelerates the work of Stream-Aligned Teams.  ","version":"Next","tagName":"h3"},{"title":"DISC Profiles​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#disc-profiles","content":" ","version":"Next","tagName":"h2"},{"title":"Project Management Team​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#project-management-team","content":" Perceu Oliveira – Dominance Emphasis on achieving results, competitiveness, and confidence. Enjoys challenges and immediate outcomes. Miguel Malini – Steadiness Emphasis on cooperation, sincerity, loyalty, and being a team player. Tends to be supportive and prefers to stay in the background. João Ferrareis – Conscientiousness Focus on quality, precision, organization, and competence. Cooperative, sincere, loyal, cautious, and attentive to details. Wal Candeia – Inactive Currently not participating in the project due to a health issue.    ","version":"Next","tagName":"h3"},{"title":"Systems and Development Team​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#systems-and-development-team","content":" Arthur Miguel – Steadiness Emphasis on cooperation, sincerity, loyalty, and being a team player. Tends to be supportive and prefers to stay in the background. Michele Altavilla – Influence Emphasis on influencing and connecting with others. Enjoys teamwork, sharing, and motivating others. Bernardo Rosa – Steadiness Emphasis on cooperation, sincerity, loyalty, and being a team player. Tends to be supportive and prefers to stay in the background. Gabriel Brito – Dominance Emphasis on achieving results, competitiveness, and confidence. Enjoys challenges and immediate outcomes.  ","version":"Next","tagName":"h3"},{"title":"Communication Plan​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#communication-plan","content":" ","version":"Next","tagName":"h2"},{"title":"Communication Platform​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#communication-platform","content":" The team has chosen Telegram as the primary communication platform. While Discord is often used in other campus projects, it tends to mix with personal chats. Telegram ensures that messages remain visible, organized, and free from unrelated content.  ","version":"Next","tagName":"h3"},{"title":"Telegram Groups​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#telegram-groups","content":" Two distinct Telegram groups have been created:  Management Group A private group that includes only the four members of the Project Management Team. This space is used for internal coordination, defining responsibilities, sharing feedback, and planning deliveries. It is not divided into topics. General Project Group This group includes all eight members from both the Management and Project &amp; Systems teams. Inside this group, Telegram's topic/thread feature is used to organize communication into specific areas: General Discussion: For daily conversation, updates, clarifying doubts, and discussing ideas between all members.Useful Links: A dedicated topic to store and share project materials such as: Google Drive links (e.g., drafts before publishing in Docusaurus)GitHub repository (CodeWise)Additional documentation or resources Announcements: A focused topic for important messages like meeting schedules, professor feedback, or deadline changes.Frontend Discussion: For questions, suggestions, and discussions specific to frontend development.Backend Discussion: For backend-related planning, architecture, and problem-solving.  ","version":"Next","tagName":"h3"},{"title":"Weekly Meetings​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#weekly-meetings","content":" The team meets weekly with all project members every Monday afternoon (or Tuesday if Monday is a holiday), right before the regular class session with the Systems Project professor. This scheduling allows real-time integration of the professor's feedback into project planning.  Common discussion topics in weekly meetings include:  Reviewing weekly progress and goalsAligning management and technical expectationsIdentifying blockers or dependenciesUpdating responsibilities and delivery timelinesSyncing project documentation statusDiscussing professor or stakeholder feedbackPlanning upcoming tasks and priorities  ","version":"Next","tagName":"h3"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#backlog","content":"   ID\tFeature\tDescription\tImportance\tProposal1\tCode Analysis\tImplement validation rules (style, security, performance, best practices), with integration to Gemini API and AgentOps. Include incremental analysis to avoid reprocessing.\t100\tImprove code quality by 20% 2\tPlatform Integration\tConnect via GitHub Webhooks, n8n, and allow automatic comments on GitHub and messages on Discord. Add future support for Slack/GitLab.\t95\tAutomate code review process by 70% 3\tIntelligent Feedback\tCreate contextualized improvement suggestions, format comments and messages clearly for channels.\t90\tIncrease adoption of best practices by 25% 4\tVisualization and Metrics\tDisplay individual and collective statistics, PR scores, activity history, and monitoring dashboard. Interface for visualization in API frontend.\t85\tProvide visibility on quality evolution 5\tObservability and Monitoring\tMonitor response time, log errors, and agent activities with AgentOps support. Implement cache and parallel workers.\t80\tEnsure 99.5% service availability 6\tAdministration and Configuration\tManage API keys, permissions, URLs, and database via configuration interface.\t75\tSimplify platform management 7\tTestability and Quality\tRefactor to use dependency injection, mocks, and unit tests in Models and Controllers. Automated coverage.\t70\tAchieve 80% test coverage 8\tPerformance and Scalability\tAdd asynchronous processing with queues (Redis, RabbitMQ, etc.). Process multiple PRs in parallel.\t65\tReduce response time by 40% 9\tDocumentation (Docusaurus)\tMigrate all documentation to Markdown structure in Docusaurus, with technical guides, overview, and usage instructions.\t60\tImprove adoption by new users 10\tTests and Quality\tImplement automated test coverage with Jest and Pytest, separation of logic and external services for easy mocking, dependency injection for APIs, and incremental code analysis.\t55\tReduce production bugs by 30%   ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#general-planning","content":" Release 1.0 (Done): Send Feedback about a code to developerRelease 2.0 (Undefined): Code Analysis &amp; Platform IntegrationRelease 3.0 (Undefined): Feedback System &amp; VisualizationRelease 4.0 (Undefined): Performance &amp; Quality Enhancements      ","version":"Next","tagName":"h2"},{"title":"Release 1.0 - 01/11/2024​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/code_wise/project_managment#release-10---01112024","content":" Goal: Send Feedback about a code to developer. Features: ID 1 Intercep and analyses a code when a pul request is performedSend information about analysis to a DIscord ChannelSend information about analysis to a pull request`s commentProblems: Spend much time to analysis many code, using GPT4 Oportunity Develop our IA to improve time and no spend money with GPT4 Deadline I 01/10/2023: Send Feedback about a code to developer.  ","version":"Next","tagName":"h2"},{"title":"Understanding the Language","type":0,"sectionRef":"#","url":"/leds-tools-public/andes/lang","content":"","keywords":"","version":"Next"},{"title":"Project Structure​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#project-structure","content":" This constructor allows you to define essential details about the project, including the project's name, a description summarizing its goals and features, its purpose, and a miniworld that provides context for the project.  overview Name // Replace &quot;Name&quot; for what you want to be de ID overview { name: &quot;Cool Project&quot; // project's name description: &quot;That's a cool project&quot; // description about the project purpose: &quot;This project can make the people be cool&quot; // the purpose of this project. miniworld: &quot;You can write as much as you want&quot; // The Context about the project }   ","version":"Next","tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#requirements","content":" Requirements outline the essential aspects of a system, including its name and a brief description of its objectives. They specify functional and non-functional needs, detailing what the system should accomplish, its performance characteristics, and business rules to ensure compliance with policies.  requirements RequirementsID // Replace &quot;RequirementsID&quot; for what you want to be de ID requirements { name: &quot;module requirements&quot; // module's name description: &quot;module requirements&quot; // description about the module // Here are the functional, non-functional requirements and business rules }   Inside the requirements Model   functional_requirement FR01 { description: &quot;This system should be able to manage clients&quot; priority: &quot;High&quot; depend: RequirementsID.FR03 } non_functional_requirement NFR01 { description: &quot;The system must ensure that, in each action confirmation, the potential impacts of the action are presented in a clear and understandable way to the user&quot; priority: &quot;Medium&quot; depend: RequirementsID.FR01 } bussines_rule BR01 { description: &quot;This system should be link with paypal&quot; priority: &quot;Low&quot; depend: RequirementsID.NFR01 }   In this structure, the system can accommodate multiple functional and non-functional requirements, as well as business rules within the same module. To add additional requirements, simply change the identifier (e.g., FR01, NFR01, BR01) accordingly.  ","version":"Next","tagName":"h2"},{"title":"Actors​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#actors","content":" Actors represent the individuals or entities that interact with the system. Each actor is identified by a unique identifier and includes a name that designates their role. Additionally, an optional description can provide further details about the actor's function or responsibilities within the system, clarifying how they engage with the various components and processes.  actor ActorID // Replace &quot;ActorID&quot; with the identifier for the actor { name: &quot;Roberto&quot; // Name of the actor description: &quot;Description of the actor's role or function&quot; // Optional: detailed description of the actor }   ","version":"Next","tagName":"h2"},{"title":"Use Case​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/andes/lang#use-case","content":" The use case structure defines the interactions between actors and the system to achieve specific goals. It includes essential details such as the use case's identifier, name, description, dependencies, and the actor involved.  usecase UC01 // Replace &quot;UC01&quot; with the identifier for the use case { name: &quot;Use Case Name&quot; // Name of the use case description: &quot;Description of the use case&quot; // Detailed description of the use case depend: UC01, UC02 // Optional: list of dependent use cases performer: ActorID // The actor(s) involved in the use case requirements: RequirementsID.RF01 // The requirement(s) involved in the use case // Here are the Events }   Events are defined within the use case to represent specific actions or occurrences that take place. Each event includes its identifier, name, description, dependencies, and an action description if applicable.  event EventID // Replace &quot;EventID&quot; with the identifier for the event { name: &quot;Event Name&quot; // Name of the event description: &quot;Description of the event&quot; // Detailed description of the event depend: UC01.EventID // Optional: identifier of the dependent use case and event requirements: RequirementsID.RF01 // Optional: The requirement(s) involved in the event action: &quot;Action description&quot; // Optional: description of the action performed during the event }  ","version":"Next","tagName":"h2"},{"title":"Reporting & Visualization Library – leds-tools-made-lib","type":0,"sectionRef":"#","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib","content":"","keywords":"","version":"Next"},{"title":"Purpose​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#purpose","content":" Generates markdown documentation and SVG diagrams from JSON or .made-derived data. This is the core reporting and visualization engine.  ","version":"Next","tagName":"h2"},{"title":"Main Components​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#main-components","content":" ","version":"Next","tagName":"h2"},{"title":"Models (models.ts)​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#models-modelsts","content":" Data classes for Project, Sprint, Issue, etc.  ","version":"Next","tagName":"h3"},{"title":"Markdown Services​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#markdown-services","content":" MarkdownService.ts: Orchestrates documentation generation.MarkdownBacklogService.ts, MarkdownTimeBoxService.ts, MarkdownRoadmapService.ts: Generate content for each respective domain.  ","version":"Next","tagName":"h3"},{"title":"Chart Generators​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#chart-generators","content":" CumulativeFlowDiagram.ts, ProjectCFD.ts, ProjectThroughputGenerator.ts, etc.  ","version":"Next","tagName":"h3"},{"title":"Dependency Analysis​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#dependency-analysis","content":" ProjectDependencyAnalyzer.ts: Outputs Mermaid diagrams.  ","version":"Next","tagName":"h3"},{"title":"Graph Utilities​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#graph-utilities","content":" graph.ts: Builds task-dependency graphs and checks cycles.  ","version":"Next","tagName":"h3"},{"title":"Key Directories​","type":1,"pageTitle":"Reporting & Visualization Library – leds-tools-made-lib","url":"/leds-tools-public/made/Architecture/leds-tools-made-lib#key-directories","content":" markdown/ # MarkdownBacklogService, TimeBoxService, etc. chart/ # SVG chart generators like CFD, throughput, dependencies example/ # Generated markdown reports and diagrams util/ # Common helpers (file paths, formatting)  ","version":"Next","tagName":"h2"},{"title":"GitHub Actions Automation – leds-tools-made-githubaction","type":0,"sectionRef":"#","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction","content":"","keywords":"","version":"Next"},{"title":"Purpose​","type":1,"pageTitle":"GitHub Actions Automation – leds-tools-made-githubaction","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction#purpose","content":" Automates report generation using the Docker tool and sends notifications via Discord.  ","version":"Next","tagName":"h2"},{"title":"Main Components​","type":1,"pageTitle":"GitHub Actions Automation – leds-tools-made-githubaction","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction#main-components","content":" ","version":"Next","tagName":"h2"},{"title":"GitHub Workflows​","type":1,"pageTitle":"GitHub Actions Automation – leds-tools-made-githubaction","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction#github-workflows","content":" made-report.yml: Generates reports on schedule, push, or manually.discord-notify.yml: Sends daily updates to Discord.  ","version":"Next","tagName":"h3"},{"title":"Config & Secrets​","type":1,"pageTitle":"GitHub Actions Automation – leds-tools-made-githubaction","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction#config--secrets","content":" directories.json: Tells the container which paths to process.Secrets: DISCORD_WEBHOOK, GITHUB_TOKEN  ","version":"Next","tagName":"h3"},{"title":"Data Structure​","type":1,"pageTitle":"GitHub Actions Automation – leds-tools-made-githubaction","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction#data-structure","content":" /example/db/: Holds project JSONs (backlog, issue, roadmap, etc.)/example/*.md: Generated documentation  ","version":"Next","tagName":"h3"},{"title":"Key Directories​","type":1,"pageTitle":"GitHub Actions Automation – leds-tools-made-githubaction","url":"/leds-tools-public/made/Architecture/leds-tools-made-githubaction#key-directories","content":" .github/workflows/ # Automation workflows config/ # directories.json example/db/ # Source data (JSON) example/sprints/ # Output markdown reports  ","version":"Next","tagName":"h2"},{"title":"1. Proposed Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/made/entrega_1","content":"","keywords":"","version":"Next"},{"title":"Architecture Layers​","type":1,"pageTitle":"1. Proposed Architecture","url":"/leds-tools-public/made/entrega_1#architecture-layers","content":" ","version":"Next","tagName":"h2"},{"title":"1. Presentation Layer​","type":1,"pageTitle":"1. Proposed Architecture","url":"/leds-tools-public/made/entrega_1#1-presentation-layer","content":" UI / Web / API Gateway  ","version":"Next","tagName":"h3"},{"title":"2. Application Layer​","type":1,"pageTitle":"1. Proposed Architecture","url":"/leds-tools-public/made/entrega_1#2-application-layer","content":" Use CasesServices  ","version":"Next","tagName":"h3"},{"title":"3. Domain Layer​","type":1,"pageTitle":"1. Proposed Architecture","url":"/leds-tools-public/made/entrega_1#3-domain-layer","content":" EntitiesBusiness Rules  ","version":"Next","tagName":"h3"},{"title":"4. Infrastructure Layer​","type":1,"pageTitle":"1. Proposed Architecture","url":"/leds-tools-public/made/entrega_1#4-infrastructure-layer","content":" DatabaseRepositoriesIntegrations (e.g., MADE)    2. Layer Explanation  Presentation Layer Responsible for exposing REST/GraphQL interfaces or web UI (React/Vue) to users and other systems.Orchestrates requests and converts input/output data into DTOs. Application Layer Contains Use Cases that implement business scenarios (e.g., &quot;Create Sprint,&quot; &quot;Generate Roadmap,&quot; etc.).Should not contain infrastructure logic or direct database access. Domain Layer The core of the application, with entities (such as Epic, UserStory, Sprint) and their pure business rules (validations, calculations).Independent of frameworks and external libraries. Infrastructure Layer Implements details such as data repositories (SQL/NoSQL), HTTP clients to integrate with the MADE engine, queue services, caching mechanisms, and logging.Provides concrete implementations of the interfaces defined in the application and domain layers.    3. Bibliographic References  Robert C. Martin, Clean Architecture: A Craftsman’s Guide to Software Structure and Design, 2017.Eric Evans, Domain-Driven Design: Tackling Complexity in the Heart of Software, 2004.Vaughn Vernon, Implementing Domain-Driven Design, 2013.Martin Fowler, Patterns of Enterprise Application Architecture, 2002.    4. Improvement Points  Interface Isolation Extract repository and service interfaces into separate packages to facilitate testing and allow implementation swaps without impact. CQRS and Event Sourcing For reporting and dashboard modules (burn-down, velocity), separate read and write operations using Command Query Responsibility Segregation and potentially Event Sourcing for detailed traceability. Micro–frontends or Modularized APIs Split the presentation layer into micro-frontends (backlog management, sprint planning, roadmap) or micro-APIs for scalability and independent deployment. Integration Test Automation Introduce automated tests that simulate complete end-to-end flows against a MADE staging environment, ensuring minimal regressions in each release. Observability and Telemetry Incorporate metrics tools (Prometheus/Grafana) and distributed tracing (OpenTelemetry) to monitor performance and debug production issues. Contract Documentation (OpenAPI/AsyncAPI) Generate interactive documentation for endpoints and events to facilitate the integration of new clients and external teams.   ","version":"Next","tagName":"h3"},{"title":"MADE Project Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/made/Architecture/overview","content":"","keywords":"","version":"Next"},{"title":"Architecture Diagram​","type":1,"pageTitle":"MADE Project Overview","url":"/leds-tools-public/made/Architecture/overview#architecture-diagram","content":"  ","version":"Next","tagName":"h2"},{"title":"DSM:","type":0,"sectionRef":"#","url":"/leds-tools-public/made/dsm","content":"DSM:","keywords":"","version":"Next"},{"title":"Frequently Asked Questions","type":0,"sectionRef":"#","url":"/leds-tools-public/made/faq","content":"","keywords":"","version":"Next"},{"title":"Where is the Project ID in Jira?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/leds-tools-public/made/faq#where-is-the-project-id-in-jira","content":" You can find it directly from the link you use to view Jira, for example: example-link-jira.atlassian.net/jira/software/projects/PROJECTID/boards/1 Here, the Project ID is immediately after /projects/  ","version":"Next","tagName":"h2"},{"title":"Where to get the Jira API Token?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/leds-tools-public/made/faq#where-to-get-the-jira-api-token","content":" To get the API Token, you need to be an administrator of the organization in Jira. If you are an administrator, follow this tutorial from Jira. Below is a simplified version:  Log in to https://id.atlassian.com/manage-profile/security/api-tokens.Click on Create API token.In the dialog that appears, enter a name for your token and click Create.Click Copy to clipboard.Congratulations, you have your API Token.  ","version":"Next","tagName":"h2"},{"title":"Where to find the Project Link?​","type":1,"pageTitle":"Frequently Asked Questions","url":"/leds-tools-public/made/faq#where-to-find-the-project-link","content":" You can get it directly from the link you use to view Jira, for example: https:/example-link-jira.atlassian.net/jira/software/projects/PROJECTID/boards/1 Here, we only take the main part of the link. ","version":"Next","tagName":"h2"},{"title":"How to Use","type":0,"sectionRef":"#","url":"/leds-tools-public/made/howtouse","content":"How to Use Create a file with any name and the .made extension.Define what will be generated using the MADE language.Save the .made file.Right-click anywhere inside the file and choose &quot;Synchronize With Project Management.&quot;After that, it will sync what was described in the file to your project management tool (e.g., Jira).","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/made/overview","content":"Overview MADE (Management as a Code) is an innovative plugin that helps Project Management and development teams efficiently create backlogs and sprints. It emphasizes process reuse and standardization, streamlining task management across projects. Presentation about Made: Agile Management with MADE","keywords":"","version":"Next"},{"title":"Instalation","type":0,"sectionRef":"#","url":"/leds-tools-public/made/installation","content":"Instalation To install Made, follow these steps: Open Visual Studio CodeClick on ExtensionsSearch for MadeClick to install the Made extension by LEDS IFES","keywords":"","version":"Next"},{"title":"DISC","type":0,"sectionRef":"#","url":"/leds-tools-public/made/plano_comunicacao","content":"DISC Purpose: Record the DISC results of GPS and MADE members. If something is incorrect, please report it or submit a PR. Name\tDominance\tInfluence\tSteadiness\tConscientiousnessMafe Mattos ✔️ Lucas Lopes Marlon Silva Breno Ricardo Ferreira Antunes\t✔️ Luiz Zottich Josias Neves ✔️ Breno Amâncio Affonso ✔️ Rafael Barros Leão Borges ✔️ Paulo Sousa Sanches Lopes ✔️ Jonathan Castro Silva ✔️ Breno Scalzer\t✔️ Nathan ✔️ Team Topology This team diagram outlines roles, objectives, and communication flow: Team Type\tTeam Name\tMembers\tObjective\tMain InteractionStream-aligned\tGPS Team\tMafe, Lucas, Marlon, Breno R. Antunes, Luiz\tManage adoption, governance, and evolution of MADE in Project X\t↔ MADE Team (feedback &amp; support) Platform Team\tMADE Team\tJosias N., Breno A. Affonso, Rafael B. Leão Borges, Paulo S. S. Lopes, Josias N. Borba, Jonathan C. Silva\tDevelop, maintain, and evolve the MADE platform (DSL, APIs, dashboards)\t↔ GPS Team (requirements &amp; usage) Enabling Team\tAgile Coaches\t— (external consultants)\tEnable teams in agile methods and in using the MADE DSL\t↔ GPS &amp; MADE Interaction Flow GPS Team → MADE Team: requests for new features, operational support, and improvement suggestions.MADE Team → GPS Team: platform releases, fixes, technical documentation, and training.Agile Coaches → GPS/MADE: workshops, coaching sessions, and practice reviews. Backlog GPS Team backlog for MADE management, prioritized by impact on success and adoption. ID\tType\tTitle\tDescription\tPriorityEPIC-01\tEpic\tMADE Governance &amp; Support\tStructure roles, processes, and communication for effective MADE governance\tHigh US-01\tStory\tDefine Roles &amp; Responsibilities\tDocument and publish on Docusaurus the usage, support, and evolution roles for MADE\tHigh US-02\tStory\tCreate DSL Usage Guide\tCreate section “Modeling EPICs, User Stories, Sprints, and Releases” in the docs\tHigh US-03\tStory\tConfigure Discord Support Channel\tCreate server and specific channels for MADE questions, support, and announcements\tMedium US-04\tStory\tEstablish CI/CD Alerts\tSet up build/test/release notifications on Discord and WhatsApp\tMedium US-05\tStory\tDevelop Metrics Dashboards\tValidate and present burndown, velocity, and sprint status on the site and Discord\tMedium TASK-01\tTask\tWorkshop “How to Manage MADE”\tConduct internal training with Agile Coaches via Discord\tHigh TASK-02\tTask\tPublish Initial Documentation on Docusaurus\tDeploy docs on Docusaurus site and validate access\tHigh TASK-03\tTask\tMonitor Adoption &amp; Gather Feedback\tCollect usage data and feedback in #feedback-made and adjust backlog as needed\tMedium Communication Plan Defines channels, frequency, and responsible parties to keep everyone aligned. From\tTo\tChannel\tFrequency\tFormat\tResponsibleGPS Team\tGPS Team\tDiscord (#daily-standup)\tDaily (09:00)\tDaily Stand-up (voice + text)\tMarlon Silva GPS Team\tMADE Team\tDiscord (📹 video call)\tWeekly (Wed 14:00)\tSync Meeting (30 min)\tLucas Lopes GPS Team\tAgile Coaches\tDiscord (#training)\tBiweekly\tInteractive Workshop\tMafe Mattos MADE Team\tGPS Team\tDiscord (#releases)\tEach release\tRelease Notes + Q&amp;A\tRafael Barros L. Borges GPS Team ↔ MADE\t—\tWhatsApp (“MADE Support” group)\tContinuous/urgent\tIncident alerts\tPaulo Sousa S. Lopes GPS Team\tCourse Stakeholders\tEmail\tBiweekly\tProgress Report (PDF)\tBreno R. F. Antunes GPS &amp; MADE\tGPS &amp; MADE\tDiscord (voice)\tMonthly\tRetrospective\tMarlon Silva","keywords":"","version":"Next"},{"title":"Project Model Canvas","type":0,"sectionRef":"#","url":"/leds-tools-public/made/pmc","content":"","keywords":"","version":"Next"},{"title":"Justifications (Past)​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#justifications-past","content":" Low visibility of priorities and progressDifficulty adapting quickly to scope changesRework and delivery delays due to lack of standardizationRepetitive effort configuring sprints, backlogs, and releases  ","version":"Next","tagName":"h2"},{"title":"SMART Objectives​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#smart-objectives","content":" Reduce by 50 % the average sprint-planning timeDecrease by 30 % the occurrences of rework caused by manual processes and lack of standardizationIncrease by 100 % transparency about progress and priorities for all stakeholders  ","version":"Next","tagName":"h2"},{"title":"Benefits (Future)​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#benefits-future","content":" Faster deliveries: shorter development cycles and releases, accelerating time-to-marketRework reduction: artifact and “as-code” workflow standardization cuts errors and rework by up to 30 %Greater transparency: real-time visibility of backlog, sprints, and task status for all stakeholdersPlanning optimization: automation of repetitive tasks reduces sprint-organization time by up to 50 %  ","version":"Next","tagName":"h2"},{"title":"Product​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#product","content":" Agile-Management Modules: definition and management of EPICs, user stories, and tasks via DSLIntegrated Backlog: product and sprint backlogs prioritized and accessible to everyoneSprint Planning: configurable time-boxes with automatic assignment of ownersReusable Workflows &amp; Templates: parameterized templates for EPICs, stories, and processes (review, deploy)Dashboards &amp; Metrics: burndown, velocity, and quality indicators for continuous monitoring  ","version":"Next","tagName":"h2"},{"title":"Requirements​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#requirements","content":" Team registration with roles, skills, and competencies to allocate resources efficientlyVersioned release roadmap linking EPICs and user stories to versions, with planned start and end datesReusable workflows and templates for common processes (code review, design approval, deploy) ensuring standardization and rapid setupDashboards and metrics (burndown, velocity, quality indicators) for real-time tracking of progress and performanceFull history and traceability of all definitions (versioned management artifacts) for audits and lessons learnedRole-based access control, ensuring proper visibility and security for each stakeholderIntegration with testing and CI/CD tools, enabling continuous quality control and automated validation before each release  ","version":"Next","tagName":"h2"},{"title":"External Stakeholders​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#external-stakeholders","content":" Executive SponsorProject ManagerProduct OwnerScrum MasterDevelopment TeamQA / Testing TeamOperations / DevOps TeamDesigner / UXEnd Users / CustomersGamma Support Team (MADE)  ","version":"Next","tagName":"h2"},{"title":"Assumptions​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#assumptions","content":" Skilled Team: members knowledgeable in agile (Scrum/Kanban) and “as-code” syntax for adopting MADE’s DSLStable MADE Platform: tool available and performant for modeling EPICs, stories, sprints, and releases without interruptionsSupport &amp; Training: Gamma team available to answer initial questions and provide training  ","version":"Next","tagName":"h2"},{"title":"Risks​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#risks","content":" Risk\tChance\tMitigationStudents drop the course\t7/10\tAssign pairs to carry out the activities Scheduling conflicts among team members\t8/10\tOrganize efficient communication channels  ","version":"Next","tagName":"h2"},{"title":"Team​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#team","content":" Mafe MattosLucas LopesMarlon SilvaBreno Ricardo Ferreira AntunesLuiz ZottichJosias NevesBreno Amâncio AffonsoRafael Barros Leão BorgesPaulo Sousa Sanches LopesJosias Neves Jardins BorbaJonathan Castro Silva  ","version":"Next","tagName":"h2"},{"title":"Delivery Group​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#delivery-group","content":" 4 weeks: Develop Requirements Document and Diagrams2 weeks: Learn project technologies3 weeks: Develop solution2 weeks: Testing and bug fixes3 weeks: Deployment  ","version":"Next","tagName":"h2"},{"title":"Timeline​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#timeline","content":" Weeks 1–4: Requirements Document and DiagramsWeeks 5–6: Technology LearningWeeks 7–9: Solution DevelopmentWeeks 10–11: Testing and Bug FixesWeeks 12–14: Deployment  ","version":"Next","tagName":"h2"},{"title":"Constraints​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#constraints","content":" Learn TypeScript and LangiumAvailable time  ","version":"Next","tagName":"h2"},{"title":"Costs​","type":1,"pageTitle":"Project Model Canvas","url":"/leds-tools-public/made/pmc#costs","content":" 100 hours of estimated effort per member ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/made/project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/made/project_managment#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tCreate basic project element on jira\tCreate EPIC, US, Task, Sprint on Jira\t100\tImprove projet management in 5% 2\tDefine responsable by Task and deadline\tDefine a team member as reponsible for a Task\t98\tImprove projet management in 10% 3\tCreate Documentaion by project management\tCreate a documentation in markdown about project management\t90\tImprove comunication in 15% 4\tDefine project roadmap\tDefine roadmap from a project\t80\tImprove comunication in 15% 5\tDefine Analyis about task relation\tDefine a analysis about relation amon task e create a developing path\t97\tImprove management in 20% 6\tDefine Project management templates\tDefine templates of EPIC, US e Task based on BPMN process\t93\tImprove management in 20%  ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/made/project_managment#general-planning","content":" Release 1.0 - (Undefined): Create basic elements and documenation on jira (ID1, ID2 and, ID3)Release 2.0 - (Undefined): Create analysis and roadmap about project (ID4 and ID5)Release 3.0 - (Undefined): Define task templates in a repository (ID6) ","version":"Next","tagName":"h2"},{"title":"Metrics","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/","content":"Metrics This page documents the key metrics used to monitor and improve our project performance. Each metric includes a definition, purpose, calculation method, how will we measure it, and the impact it'll have in the project. We also provide a website that dynamically updates the graphs of these metrics using real-time data fetched from our GitHub projects. This ensures that our visualizations always reflect the most up-to-date project status: Live Metrics Dashboard Access our dynamic dashboard with real-time metrics from GitHub: 📊 Open the live site 🔁 Throughput Measure the number of work items (like features or bug fixes) completed per unit of time. It helps answer, &quot;How much work are we getting done?&quot; 📈 BurnUp Track your team's progress against the total project scope. This chart clearly shows work completed, total scope, and the expected completion date. ⏱️ Lead Time Understand the total time elapsed from the moment a work item is requested until it is delivered. It reflects the entire customer experience. 🔄 Cycle Time Focus on the active development time. This measures the time from when work begins on an item until it is ready for delivery. It answers, &quot;How long does it take to do the work?&quot;","keywords":"","version":"Next"},{"title":"BurnUp","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/burnup","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-definition","content":" A visual tool that shows the amount of work completed over time compared to the total work planned.  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-purpose","content":" To track progress toward a goal, visualize scope changes, and understand if the team is on track to meet deadlines.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-calculation-method","content":" X-axis: Time (e.g., sprints or days)Y-axis: Work items (e.g., number of issues or story points)Plot two lines: Completed work line: Cumulative count of completed items.Total work line: Constant or adjusted if scope changes.  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure in the project?​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-how-will-we-measure-in-the-project","content":" We will use data from GitHub Projects for measurement, monitoring the number of open and closed issues over time. Thus, the Burnup chart will be built based on the accumulation of closed issues in relation to the total planned for each sprint.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"BurnUp","url":"/leds-tools-public/oraculo/metrics/burnup#-project-impact","content":" The Burnup allows us to compare the flow of incoming issues in the project with their resolution, evaluating the development team's ability to complete tasks within the expected timeframe. From this metric, it's possible to estimate a satisfactory volume of new issues to be defined in a sprint and to identify deviations such as delays or an increase in tasks. ","version":"Next","tagName":"h3"},{"title":"Understanding the Language","type":0,"sectionRef":"#","url":"/leds-tools-public/made/lang","content":"","keywords":"","version":"Next"},{"title":"Meta Model​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#meta-model","content":"   ","version":"Next","tagName":"h2"},{"title":"Project​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#project","content":" This constructor enables the configuration of the MADE and JIRA integration. A Project is composed of:  Id: Project Jira`s ID (e.g., DEV, INFRA). Each JIRA project has a IDdescription: a description about the projectemail: user's email that has permition to create JIRA's elements using JIRA's APIhost: jira host (e.g., devxyz.jira.com)token: Token that allows to create elements using JIRA's API.  Example:  project { name: &quot;Modulo de Autentication, Autorization e Accounting&quot; description: &quot;Modulo responsável pela autenticação, autorização e rastreio do usuário no sistema&quot; startDate: 22/11/2022 dueDate: 30/11/2022 }   ","version":"Next","tagName":"h2"},{"title":"Team​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#team","content":" It allows us create teams that will be responsible for one or more tasks. MADE allows creating as many teams as we want.  It is important to comment that each member needs to be registered on JIRA.  team blackops { name: &quot;Team Black Ops&quot; description: &quot;Equipe responsável por produzir artefatos de segurança&quot; teammember rafaelemerick {name: &quot;Rafael Emerick&quot; email: &quot;rafael.emerick@blackops.com.br&quot;} teammember joaomarcos {name: &quot;João Marcos &quot; email: &quot;joao.marcos@blackops.com.br&quot;} teammember Arthur {name: &quot;Arthur Cremasco&quot; email: &quot;arthur.cremasco@blackops.com.br&quot;} }   ","version":"Next","tagName":"h2"},{"title":"Backlog​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#backlog","content":" It allows us to define a project backlog. MADE allows to creating as many backlogs as we want.  A backlog is composed of: EPIC, User Story, and Task. Link about EPIC, USer Story and Task.  A Epic is composed of User Stories and User Stories is composed of tasks. MADE allows to define this relation. Beside allow us define a relation of dependecies, i.e., It is possible to define that a task will be performed only when other task or user story was performed.  backlog Spike { name: &quot;Backlog de Estudo&quot; description: &quot;Backlog dedicado a estudo da equipe&quot; epic epic1 { name: &quot;Estudar sobre Autorização&quot; description: &quot;Estudo sobre autorização de usuários a recursos de redes&quot; story story1 { name: &quot;Estudar a arquitetura proposta pelo OPA&quot; task estudar { name: &quot;Estudar sobre OPA&quot; } task apresentar { name: &quot;Apresentar o estudo OPA&quot; depends: Spike.epic1.story1.estudar, Spike.epic1.story2.estudar } } story story2 { name: &quot;Estudar a arquitetura proposta pelo OpenFGA&quot; task estudar { name: &quot;Estudar sobre OpenFGA&quot; } task apresentar { name: &quot;Apresentar o estudo OpenFGA&quot; depends: Spike.epic1.story1.estudar, Spike.epic1.story2.estudar } } } }   ","version":"Next","tagName":"h2"},{"title":"Sprint​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#sprint","content":" Define a work period for the project team (e.g., sprint) with work tasks, responsible by time box and other data to manager a timebox.   sprint estudo { name: &quot;Estudar Autorizacao&quot; description: &quot;Realizar estudos sobre autorizacao&quot; startDate: 20/11/2024 endDate: 30/11/2024 status: IN_PROGRESS sprintbacklog estudo { item Spike.epic1.story1.estudar {assignee: blackops.joaomarcos dueDate: 30/11/2024 status: TODO} item Spike.epic1.story1.apresentar {assignee: blackops.joaomarcos startDate: 20/11/2024 completedDate:26/11/2024 dueDate: 30/11/2024 status: DONE} item Spike.epic1.story2.apresentar {assignee: blackops.joaomarcos startDate: 20/11/2024 dueDate: 30/11/2024 status: DOING} } }   Definition:  Label: A label is a tag that can be used to track activities of a specific department, categorizing tasks. Complexity: Indicates the complexity of items, represented by an integer. Planning: References items from the backlog, inserting them into the sprint and creating the Sprint Backlog. Performed: References items from the planning and assigns their status as DOING or DONE. This is useful for sprint reviews, as it allows the status of tasks within the timebox to be checked.  ","version":"Next","tagName":"h2"},{"title":"Process​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#process","content":" In projects, it's common for some activities to be repeated throughout their duration. To handle this, we've introduced the concept of a process, which can be used to instantiate repetitive activities in the project.  process DevelopmentProcess { name: &quot;Development Process&quot; description: &quot;Description of a process&quot; activity UseCaseModelling { name: &quot;Use Case Modelling&quot; description: &quot;Use Case Modelling&quot; DefinitionDone: &quot;The criteria that define when the activity is considered complete.&quot; DefinitionReady: &quot;The criteria that define when the activity is ready to be worked on.&quot; Learning: &quot;Specifies what needs to be studied or learned for the activity.&quot; Label: UseCaseModelling } task UseCaseDescription { name: &quot;Use Case Description&quot; description: &quot;Use Case Description &quot; DefinitionDone: &quot;The criteria that define when the activity is considered complete.&quot; DefinitionReady: &quot;The criteria that define when the activity is ready to be worked on.&quot; Learning: &quot;Specifies what needs to be studied or learned for the activity.&quot; Label: UseCaseDescription Depends: DevelopmentProcess.UseCaseModelling } }   The dependency can occur in both the user story and the epic, functioning in the same way.  ","version":"Next","tagName":"h2"},{"title":"RoadMap​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#roadmap","content":" Define o roteiro, suas versões e o planejamento das versões.  roadmap projeto { name: &quot;Rodmap do projeto&quot; description: &quot;Roadmap de todo do projeto&quot; milestone beta { name: &quot;Primeira versão&quot; description: &quot;Contem apenas estudo das tecnologias do projeto&quot; startDate: 20/11/2024 dueDate: 30/11/2024 status: IN_PROGRESS release beta { description: &quot;Estudo para entender as tecnologias&quot; item : Spike.epic1 status: IN_DEVELOPMENT dueDate: 30/11/2024 version: &quot;1.0&quot; } } }   ","version":"Next","tagName":"h2"},{"title":"Examples:​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/made/lang#examples","content":" Simple Example: Example with Team, Sprint, Backlog.Simple Example with Roadmap: Example Team, Sprint, Backlog, and Roadmap. ","version":"Next","tagName":"h2"},{"title":"Architecture and Modularization","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/architecture","content":"","keywords":"","version":"Next"},{"title":"Main Components​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#main-components","content":" 🔁 Airbyte (ETL) Responsible for extracting data from GitHub (issues, pull requests, etc.), transforming and loading it into the PostgreSQL database. The current approach captures data from Airbyte's temporary cache, transforms it, and inserts it into a custom relational schema with normalized tables. This improves compatibility with Vanna and enables more accurate SQL generation. ⚙️ Backend (FastAPI) API developed with FastAPI. It acts as a bridge between the user and the database: receives questions, uses the AI to generate SQL queries, executes them, and formats the responses. Pattern used: MVC (Model, View, Controller) 🧠 MyVanna (LLM/AI) AI component that uses Google's Gemini model and ChromaDB. It interprets user questions, generates SQL, runs queries, and translates responses into natural language. Responsibilities: Understands the database schemaGenerates and runs SQL queriesLearns from custom examples Additionally, to validate AI responses, the system now includes semantic similarity tests using Google BERT. These tests compare the generated SQL with expected queries using cosine similarity. If similarity is below 60%, the response is flagged as poor quality. 🌐 OpenWebUI (Graphical Interface) The visual interface where the user interacts with the system, submits questions, and receives responses.  ","version":"Next","tagName":"h2"},{"title":"Overview of the Data Flow​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#overview-of-the-data-flow","content":" User (OpenWebUI interface) ↓ pipeline_api.py ↓ FastAPI (backend/API) ↓ Vanna.AI (LLM) ↓ SQL → PostgreSQL Database ↓ ↪ Response shown to the user  ","version":"Next","tagName":"h2"},{"title":"Architecture Summary by Role​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#architecture-summary-by-role","content":" Component\tRole\tDescriptionOpenWebUI\tInterface\tFrontend for user interaction FastAPI (API)\tBackend/API\tReceives questions, uses AI, queries database Airbyte\tETL\tExtracts GitHub data and loads it into PostgreSQL MyVanna\tLLM / AI\tGenerates SQL and natural language responses using Gemini + Chroma PostgreSQL\tDatabase\tStores GitHub data queried by the system  ","version":"Next","tagName":"h2"},{"title":"Design Patterns Used​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#design-patterns-used","content":" Singleton Ensures only one instance of key components like: AskController (question logic)MyVanna (AI client)airbyte (ETL process) MVC (Model-View-Controller) Applied in the API: Models: Define the structure of questions/responsesControllers: Process the logic (e.g. AskController.py)Views/Routes: Handle API endpoints (e.g. routes.py)  ","version":"Next","tagName":"h2"},{"title":"Deployment​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#deployment","content":" The entire system is containerized using Docker. Components defined in docker-compose.yml include:  db: PostgreSQL databaseback-end: Python-based API and ETLfront-end: OpenWebUI interface  Configuration files include Dockerfile.dev, Dockerfile.pub, and Dockerfile.  ","version":"Next","tagName":"h2"},{"title":"Security and Configuration​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#security-and-configuration","content":" Sensitive data is stored in .env files. This includes:  GitHub tokenDatabase passwordGemini API key  ","version":"Next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Architecture and Modularization","url":"/leds-tools-public/oraculo/architecture#testing","content":" Tests are implemented using pytest, including:  MyVanna tests (SQL generation and DB connection)Pipeline tests (question handling)API tests (/ask endpoint)AI Response Quality Tests: Implemented with BERT to evaluate the semantic similarity between expected and generated SQL queries. Tests fail if similarity drops below 60%.    The Oráculo system demonstrates how AI and GitHub integration can simplify development tracking through natural language. Its architecture is modular, follows good design principles, and is production-ready with testing, containerization, and secure configuration. ","version":"Next","tagName":"h2"},{"title":"Lead Time","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/leadtime","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-definition","content":" The total time taken from the moment a task is requested (created) to the moment it is completed (delivered).  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-purpose","content":" To evaluate the end-to-end efficiency of the process and understand how long stakeholders wait for a feature or task.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-calculation-method","content":" Subtract the task creation date from the completion date.  Formula: Lead Time = Completion date - Creation date  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure in the project?​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-how-will-we-measure-in-the-project","content":" Measurement will be based on data from GitHub Projects, considering the total time between the opening of an issue and its closure. This time represents the full work cycle for each item. Monitoring will be continuous, and the data will be analyzed at the end of each sprint, making it possible to evaluate the average delivery time for demands.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"Lead Time","url":"/leds-tools-public/oraculo/metrics/leadtime#-project-impact","content":" Lead time provides a clear view of the delivery process's agility. By tracking this metric, it becomes possible to identify delays, understand where bottlenecks occur, and improve delivery predictability. This strengthens commitment to deadlines, increases transparency with stakeholders, and supports decision-making to optimize the team’s workflow. ","version":"Next","tagName":"h3"},{"title":"Cycle Time","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/cycletime","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-definition","content":" The time taken to actively work on a task, from the moment work starts until it is completed.  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-purpose","content":" To analyze how long the team takes to process tasks once they begin working on them, helping to optimize internal workflow.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-calculation-method","content":" Subtract the task start date (when work begins) from the completion date.  Formula: Cycle Time = Completion date - Start of work date  🔎 Note: Cycle Time is always ≤ Lead Time.  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure in the project?​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-how-will-we-measure-in-the-project","content":" The measurement will be based on data from GitHub Projects, calculating the time it takes from the start of work on an issue to its completion (closure). This time covers the active development phase, without considering periods of waiting or inactivity. The analysis will be continuous, and the results will be reviewed at the end of each sprint to identify variations in development time.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"Cycle Time","url":"/leds-tools-public/oraculo/metrics/cycletime#-project-impact","content":" Cycle time is an essential metric for evaluating the efficiency of the development process. By monitoring it, the team can identify where delays are occurring in the workflow and adjust processes to reduce cycle time. This results in faster deliveries and helps increase the team’s ability to handle more tasks simultaneously, optimizing the overall project performance. ","version":"Next","tagName":"h3"},{"title":"🧙 Oráculo: Team wisdom in real time","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/overview","content":"","keywords":"","version":"Next"},{"title":"1️⃣ Get summaries of Discord conversations​","type":1,"pageTitle":"🧙 Oráculo: Team wisdom in real time","url":"/leds-tools-public/oraculo/overview#1️⃣-get-summaries-of-discord-conversations","content":" Quickly request a contextual summary of important discussions held on Discord.  Example use:  Summary of everything about Quality between May 1st and May 7th   📌 The Oráculo analyzes conversations and provides an organized, objective summary. Ideal for:  Quickly onboarding new membersUnderstanding decisions madeKeeping useful history for retrospectives    ","version":"Next","tagName":"h2"},{"title":"2️⃣ Git Integration​","type":1,"pageTitle":"🧙 Oráculo: Team wisdom in real time","url":"/leds-tools-public/oraculo/overview#2️⃣-git-integration","content":" Connected to the team's repository, the Oráculo answers key questions about development progress:  What tasks are pending for team X or product Y?Which sprint tasks are still open for product Y?  🧭 Use these questions to:  Identify bottlenecksTrack what’s still openSpeed up planning meetings  ✅ The answers are always based on the latest state of the repositories and team boards.    ℹ️ Transparency, context, and agility. The Oráculo exists to turn raw data into better decisions. ","version":"Next","tagName":"h2"},{"title":"Throughput","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/metrics/throughput","content":"","keywords":"","version":"Next"},{"title":"🧾 Definition:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-definition","content":" The number of work items (e.g., issues, tasks, user stories) completed within a given time frame (usually a sprint or week).  ","version":"Next","tagName":"h3"},{"title":"🎯 Purpose:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-purpose","content":" To measure the productivity of the team by tracking how many tasks are delivered over time.  ","version":"Next","tagName":"h3"},{"title":"🧮 Calculation Method:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-calculation-method","content":" Count the number of completed items during a specific time period.  Formula: Throughput = Number of items completed / Time period  ","version":"Next","tagName":"h3"},{"title":"📊 How will we measure it in the project?​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-how-will-we-measure-it-in-the-project","content":" Measurement will be based on data from GitHub Projects, counting the number of completed (closed) issues in each sprint. Monitoring will be continuous, and the results will be consolidated at the end of each development cycle, allowing us to identify the actual delivery volume of the team.  ","version":"Next","tagName":"h3"},{"title":"🌟 Project impact:​","type":1,"pageTitle":"Throughput","url":"/leds-tools-public/oraculo/metrics/throughput#-project-impact","content":" Throughput provides a clear view of the team’s productivity, helping to determine the ideal amount of work per sprint. By tracking this metric, it is possible to identify performance trends, adjust team capacity, and detect workflow bottlenecks. This directly contributes to more accurate planning and continuous improvement of project processes. ","version":"Next","tagName":"h3"},{"title":"Metamodel","type":0,"sectionRef":"#","url":"/leds-tools-public/made/metamodel","content":"","keywords":"","version":"Next"},{"title":"Model (Entry Point)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#model-entry-point","content":" The Model serves as the main entry point for the grammar. It consists of one mandatory Project and multiple optional components, which can include teams, processes, backlogs, and timeboxes.  ","version":"Next","tagName":"h3"},{"title":"Components​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#components","content":" Project: A required element in the Model, representing the central project that the other components relate to. This element is imported from the projects package.Team: Represents teams working within the project. This is an optional component that can be added to the Model and is imported from the team package.Process: Represents processes within the project. Like teams, it is an optional component and is imported from the processes package.Backlog: Refers to the backlog of tasks or issues in the project. It is also optional and is imported from the backlog package.TimeBox: Represents time-based elements like sprints or deadlines. It is an optional component imported from the timebox package.  ","version":"Next","tagName":"h3"},{"title":"Supporting Packages​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#supporting-packages","content":" The model also relies on some supporting packages, including:  Helpers: A package for utility or supporting elements.Terminals: Another supporting package, possibly used for defining basic terminal elements in the grammar.  ","version":"Next","tagName":"h3"},{"title":"Project​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#project","content":" The Project class defines the main entity, containing several key attributes:  name: A string representing the name of the project.email: A string for the email address associated with the project.host: A string that represents the host where the project is located.token: A string used for authentication or access within the project.    In addition to these attributes, the Project class is linked to two important components:  ","version":"Next","tagName":"h2"},{"title":"Identification Component​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#identification-component","content":" The Identification component represents a part of the project that is responsible for managing project identification. The details of this component are imported from external sources (terminals or helpers), and it is considered essential for the overall structure of the project.  ","version":"Next","tagName":"h3"},{"title":"Description Component​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#description-component","content":" The Description component handles descriptive information related to the project. Like the Identification component, its details are imported from external sources, making it an integral part of the project structure.  ","version":"Next","tagName":"h3"},{"title":"Team​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#team","content":" This class diagram represents the structure of a Team Management system, focusing on the Team and TeamMember classes. It outlines the attributes of each class and the relationship between them.    ","version":"Next","tagName":"h2"},{"title":"Team​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#team-1","content":" Description: The Team class represents a group of individuals working together on a project or within an organization.Attributes: id: A unique identifier for the team.Name: The name of the team.Label: A label used for categorizing or tagging the team.Description: A detailed description of the team's purpose, goals, or activities. Relationships: Has: Contains multiple TeamMember instances, indicating that a team comprises several members.  ","version":"Next","tagName":"h3"},{"title":"TeamMember​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#teammember","content":" Description: The TeamMember class represents an individual member of a team.Attributes: id: A unique identifier for the team member.name: The name of the team member.email: The email address of the team member.Label: A label used for categorizing or tagging the team member (e.g., role, expertise). Relationships: Belongs To: Part of one Team, indicating that each team member is associated with a specific team.  ","version":"Next","tagName":"h3"},{"title":"Process​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#process","content":" This class diagram represents the structure of a Process Management system, encompassing key elements such as Process, Activity, and Task. It also defines how these elements interact and depend on each other within the system.    ","version":"Next","tagName":"h2"},{"title":"ProcessType (Interface)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#processtype-interface","content":" Description: The ProcessType interface serves as a common type for all process-related elements (Process, Activity, and Task). It allows these classes to be referenced polymorphically, enabling dependencies to be established between different types of process elements.Note: Implemented by Process, Activity, and Task.  ","version":"Next","tagName":"h3"},{"title":"Process​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#process-1","content":" Description: The Process class represents a high-level process within the system. It can include multiple activities and has its own set of attributes that define its characteristics and state.Attributes: id: A unique identifier for the process.Name: The name of the process.Description: A detailed description of the process.DefinitionDone: Criteria that define when the process is considered complete.DefinitionReady: Criteria that define when the process is ready to begin.Learning: Learning outcomes or knowledge areas associated with the process.Label: A label used for categorizing the process. Relationships: Includes: Contains multiple Activity instances, indicating that a process comprises several activities.Depends On: Can depend on multiple ProcessType instances (Process, Activity, Task), allowing for complex interdependencies between different process elements.  ","version":"Next","tagName":"h3"},{"title":"Activity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#activity","content":" Description: The Activity class represents a specific activity within a process. Activities break down a process into manageable tasks and can include multiple tasks themselves.Attributes: id: A unique identifier for the activity.Name: The name of the activity.Description: A detailed description of the activity.DefinitionDone: Criteria that define when the activity is considered complete.DefinitionReady: Criteria that define when the activity is ready to begin.Learning: Learning outcomes or knowledge areas associated with the activity.Label: A label used for categorizing the activity. Relationships: Includes: Contains multiple Task instances, indicating that an activity comprises several tasks.Depends On: Can depend on multiple ProcessType instances (Process, Activity, Task), allowing for dependencies between different activities and processes.  ","version":"Next","tagName":"h3"},{"title":"Task​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#task","content":" Description: The Task class represents an individual task within an activity. Tasks are the smallest units of work and can depend on other tasks, activities, or processes.Attributes: id: A unique identifier for the task.Name: The name of the task.Description: A detailed description of the task.DefinitionDone: Criteria that define when the task is considered complete.DefinitionReady: Criteria that define when the task is ready to begin.Learning: Learning outcomes or knowledge areas associated with the task.Label: A label used for categorizing the task. Relationships: Depends On: Can depend on multiple ProcessType instances (Process, Activity, Task), enabling dependencies between various tasks and other process elements.  ","version":"Next","tagName":"h3"},{"title":"Interfaces and Inheritance​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#interfaces-and-inheritance","content":" ProcessType​  Description: An interface that is implemented by Process, Activity, and Task. This allows these classes to be treated uniformly when establishing dependencies, enabling flexible and dynamic relationships within the process management system.  ","version":"Next","tagName":"h3"},{"title":"Backlog​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#backlog","content":" This class diagram represents the structure of a Backlog Management system, encompassing key elements such as Backlog, Epic, AtomicUserStory, and TaskBacklog. Additionally, it integrates external components like Process and Activity to define relationships and dependencies among backlog items.    ","version":"Next","tagName":"h2"},{"title":"Backlog​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#backlog-1","content":" Description: The Backlog class serves as the primary container for all backlog items.Attributes: id: A unique identifier for the backlog.Name: The name of the backlog.Label: A label used for categorizing the backlog.Description: A detailed description of the backlog. Relationships: Contains: Holds multiple BacklogItem instances, which can be Epic, AtomicUserStory, or TaskBacklog.  ","version":"Next","tagName":"h3"},{"title":"Epic​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#epic","content":" Description: An Epic represents a large body of work that can be broken down into smaller tasks or user stories.Attributes: id: A unique identifier for the epic.Name: The name of the epic.Description: A description of the epic.DefinitionDone: Criteria that define when the epic is considered complete.replace: Indicates if the epic is replacing another item.DefinitionReady: Criteria that define when the epic is ready to begin.Label: A label used for categorizing the epic.Learning: Learning outcomes related to the epic. Relationships: Depends On: Can depend on multiple BacklogItem instances.Associated With: Linked to one Process.  ","version":"Next","tagName":"h3"},{"title":"AtomicUserStory​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#atomicuserstory","content":" Description: An AtomicUserStory represents the smallest functional unit within the backlog, typically focused on a user-centered functionality.Attributes: id: A unique identifier for the user story.Name: The name of the user story.Description: A description of the user story.DefinitionDone: Criteria that define when the user story is considered complete.DefinitionReady: Criteria that define when the user story is ready to begin.Learning: Learning outcomes related to the user story.Label: A label used for categorizing the user story. Relationships: Depends On: Can depend on multiple BacklogItem instances.Part Of: Belongs to one Epic.Associated With: Linked to one Activity.  ","version":"Next","tagName":"h3"},{"title":"TaskBacklog​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#taskbacklog","content":" Description: The TaskBacklog class represents tasks that need to be completed as part of the project.Attributes: id: A unique identifier for the task.Name: The name of the task.Description: A description of the task.DefinitionDone: Criteria that define when the task is considered complete.DefinitionReady: Criteria that define when the task is ready to begin.Learning: Learning outcomes related to the task.Label: A label used for categorizing the task. Relationships: Depends On: Can depend on multiple BacklogItem instances.Part Of: Belongs to one AtomicUserStory.Sub-Task Of: Can be a sub-task of another TaskBacklog.  ","version":"Next","tagName":"h3"},{"title":"Process​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#process-2","content":" Description: Represents processes associated with epics.Note: Imported from an external package.  ","version":"Next","tagName":"h3"},{"title":"Activity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#activity-1","content":" Description: Represents activities associated with user stories.Note: Imported from an external package.  ","version":"Next","tagName":"h3"},{"title":"Interfaces and Inheritance​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#interfaces-and-inheritance-1","content":" BacklogItem​  Description: An interface implemented by Epic, AtomicUserStory, and TaskBacklog, indicating that these classes are types of backlog items.  ","version":"Next","tagName":"h3"},{"title":"TimeBox​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#timebox","content":" This class diagram provides a comprehensive view of the TimeBox Management metamodel, illustrating how TimeBox, Planning, Performed, PlanningItem, and PerformedItem interact and depend on each other. It integrates with existing components like TeamMember, Epic, AtomicUserStory, and TaskBacklog, enabling structured planning and tracking of tasks within designated time frames. The use of the TimeBoxTask interface facilitates flexible and dynamic dependencies among various task types, ensuring effective project management and progress monitoring.    ","version":"Next","tagName":"h2"},{"title":"TimeBox​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#timebox-1","content":" Description: The TimeBox class represents a fixed period during which specific tasks or activities are planned and performed. It serves as a container for planning and tracking the progress of tasks within the designated time frame.Attributes: id: A unique identifier for the TimeBox.Name: The name of the TimeBox.Description: A detailed description of the TimeBox.startDate: The start date of the TimeBox.endDate: The end date of the TimeBox.comment: Additional comments or notes related to the TimeBox.Label: A label used for categorizing the TimeBox. Relationships: Has: Contains one Planning and one Performed instance.Responsible: Assigned to multiple TeamMember instances.Includes: Contains multiple PlanningItem and PerformedItem instances.  ","version":"Next","tagName":"h3"},{"title":"Planning​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#planning","content":" Description: The Planning class encapsulates the planning phase of a TimeBox, where various planning items are defined and organized.Attributes: planningItems: A collection of PlanningItem instances associated with the TimeBox. Relationships: Contains: Holds multiple PlanningItem instances.  ","version":"Next","tagName":"h3"},{"title":"Performed​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#performed","content":" Description: The Performed class encapsulates the execution phase of a TimeBox, where performed items are tracked and managed.Attributes: performedItems: A collection of PerformedItem instances associated with the TimeBox. Relationships: Contains: Holds multiple PerformedItem instances.  ","version":"Next","tagName":"h3"},{"title":"PlanningItem​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#planningitem","content":" Description: The PlanningItem class represents individual items that are planned within a TimeBox. These items can be tasks, user stories, or epics that need to be addressed during the TimeBox period.Attributes: itemString: A string representation of the item, used if a reference is not provided.assigneeString: A string representation of the assignee's name, used if a reference is not provided.planned: An integer indicating the amount of effort planned for the item.complexity: An integer representing the complexity level of the item.dueDate: The due date for the planned item. Relationships: Item: References a TimeBoxTask (Epic, AtomicUserStory, or TaskBacklog) or uses a string if no reference is provided.Assignee: References a TeamMember or uses a string if no reference is provided.  ","version":"Next","tagName":"h3"},{"title":"PerformedItem​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#performeditem","content":" Description: The PerformedItem class represents individual items that have been performed or completed within a TimeBox. These items track the actual progress made during the TimeBox period.Attributes: itemString: A string representation of the item, used if a reference is not provided.performed: An integer indicating the amount of effort actually performed on the item.complexity: An integer representing the complexity level of the item.status: The current status of the item, which can be either DOING or DONE. Relationships: Item: References a TimeBoxTask (Epic, AtomicUserStory, or TaskBacklog) or uses a string if no reference is provided.  ","version":"Next","tagName":"h3"},{"title":"TeamMember​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#teammember-1","content":" Description: The TeamMember class represents an individual member of a team responsible for executing tasks within a TimeBox.Attributes: id: A unique identifier for the team member.name: The name of the team member.email: The email address of the team member.Label: A label used for categorizing or tagging the team member (e.g., role, expertise). Relationships: Responsible For: Assigned to multiple TimeBox instances.Assignee: Can be assigned to multiple PlanningItem instances.  ","version":"Next","tagName":"h3"},{"title":"Epic​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#epic-1","content":" Description: The Epic class represents a large body of work that can be broken down into smaller tasks or user stories. It is a type of TimeBoxTask.Attributes: id: A unique identifier for the epic.Name: The name of the epic.Description: A description of the epic.DefinitionDone: Criteria that define when the epic is considered complete.replace: Indicates if the epic is replacing another item.DefinitionReady: Criteria that define when the epic is ready to begin.Label: A label used for categorizing the epic.Learning: Learning outcomes related to the epic. Relationships: Depends On: Can depend on multiple TimeBoxTask instances.Associated With: Linked to one Process.  ","version":"Next","tagName":"h3"},{"title":"AtomicUserStory​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#atomicuserstory-1","content":" Description: The AtomicUserStory class represents the smallest functional unit within the backlog, typically focused on a user-centered functionality. It is a type of TimeBoxTask.Attributes: id: A unique identifier for the user story.Name: The name of the user story.Description: A description of the user story.DefinitionDone: Criteria that define when the user story is considered complete.DefinitionReady: Criteria that define when the user story is ready to begin.Learning: Learning outcomes related to the user story.Label: A label used for categorizing the user story. Relationships: Depends On: Can depend on multiple TimeBoxTask instances.Part Of: Belongs to one Epic.Associated With: Linked to one Activity.  ","version":"Next","tagName":"h3"},{"title":"TaskBacklog​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#taskbacklog-1","content":" Description: The TaskBacklog class represents tasks that need to be completed as part of the project. It is a type of TimeBoxTask.Attributes: id: A unique identifier for the task.Name: The name of the task.Description: A description of the task.DefinitionDone: Criteria that define when the task is considered complete.DefinitionReady: Criteria that define when the task is ready to begin.Learning: Learning outcomes related to the task.Label: A label used for categorizing the task. Relationships: Depends On: Can depend on multiple TimeBoxTask instances.Part Of: Belongs to one AtomicUserStory.Sub-Task Of: Can be a sub-task of another TaskBacklog.  ","version":"Next","tagName":"h3"},{"title":"Interfaces and Inheritance​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#interfaces-and-inheritance-2","content":" ","version":"Next","tagName":"h2"},{"title":"TimeBoxTask​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/made/metamodel#timeboxtask","content":" Description: The TimeBoxTask interface is implemented by Epic, AtomicUserStory, and TaskBacklog. This allows these classes to be treated uniformly when establishing dependencies, enabling flexible and dynamic relationships within the TimeBox Management system. ","version":"Next","tagName":"h3"},{"title":"Todo","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Architecture of the Src Folder/documentationArchitecture","content":"Todo","keywords":"","version":"Next"},{"title":"Wellcome to Src Folder!","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Architecture of the Src Folder/overview","content":"","keywords":"","version":"Next"},{"title":"Syntax Definition Files","type":1,"pageTitle":"Wellcome to Src Folder!","url":"/leds-tools-public/spark/Architecture/Architecture of the Src Folder/overview##","content":"These files, represented by the Langium extension (.langium), are responsible for defining how the language’s syntax is structured. Each file contains a set of data that determines which reserved keywords (for context and typing) exist, which keywords are accepted in which contexts, and how they should be interpreted. In short, they define a set of Regular Expressions (Regex).    ","version":"Next","tagName":"h3"},{"title":"Construction Definition Files","type":1,"pageTitle":"Wellcome to Src Folder!","url":"/leds-tools-public/spark/Architecture/Architecture of the Src Folder/overview##","content":"These files are represented by JavaScript (.js) and TypeScript (.ts) extensions. They are programming code files that implement specific validation rules for the language, aimed at facilitating the development of language tests.   CLI  This folder is more relevant than the others. Due to its large number of subfolders and files, it will be explained in a separate section.  Extensions  This folder contains the configuration files for Spark as a VSCode extension. It defines which files should be read to extract grammar checkers, editing assistants — for example, automatically inserting a closing &quot;)&quot; when typing an opening &quot;(&quot;, as well as comment characters — and reserved keyword definitions. Additionally, it also registers commands that can be accessed via left-click on files with the .spark extension. ","version":"Next","tagName":"h3"},{"title":"Atention","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/overview","content":"Atention The architecture description was based on the most recent version in the Main branch of the Spark source repository, namely November 2024. Breif The Spark is a tool developed with Andes and is used as a plugin in VSCode, which forces its architecture to resemble other projects that have the same characteristics. Observe Image 1 to have an overview of the architecture. Image1: Architecture Overview Note that the folders are divided into two sections: the top and the bottom ones. Unfortunately, the code in the main branch of the repository is not stable, making it impossible to fully explain the completeness and exact communication between the layers. However, it is still possible to interpret their intended purpose. Thus, the top layer are explained in an incomplete and interpretive manner, while the bottom layer will be explained in detail.","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Architecture of the Src Folder/theCliFolder","content":"Introduction The CLI folder contains the necessary files to read the syntax definitions from the language folder, convert them into computational artifacts interpreted by JS/TS, and apply the commands needed to instantiate the project. Image 6: The CLI folder struct This structure follows a very interesting principle: each folder contains a corresponding Generate.ts file, which is responsible for generating the directory structure at its level and/or invoking the Generate.ts of the subsequent level. Furthermore, within the context of this level in the CLI folder, each subfolder refers to a specific command and, depending on the layer, may include subdirectories for more specific application configurations. With these mechanisms, the code becomes not only extremely organized but also allows a clear visualization of the internal layer architectures without the need for diagramming. Understanding the Generate Structure Better Consider the following example code: Configuration { software_name: &quot;Example Software&quot; // Software's name about: &quot;This software is just an example&quot; // Description about the software language: python // Language and pattern used to develop the software database_name: &quot;DataBase&quot; // Database Name } module CollModule { entity CoolGuy { name: string } } module BadModule { entity DummyGu { name: string } } When reading the .spark file above, VSCode will begin constructing the selected command by following the folder structure within the CLI level. In this structure, we have the folders: documentation;backend;frontend; andopa. The commands registered in VSCode are: generate project documentation;generate backend;generate frontend; andgenerate authorization; Sound familiar?. Thus, each folder represents a command registered in VSCode. When a command is triggered, its specific generate file is located within the folder structure. Suppose you execute the command generate backend. Then, VSCode will call the Generator.ts file inside the CLI folder and pass the parameters defined in the configuration section of the .spark file. The Generator.ts file will then locate the specific generate file corresponding to the provided parameters—in our case, it accesses the backend folder (as the generation command is generate backend), then accesses the python folder (as specified in the project configuration), and finally calls the generate.ts file. The generate.ts file, in turn, understands its internal structure and proceeds to create the necessary folders at its level, continuing to call the respective generate.ts files at lower levels, until the entire folder structure is properly built. As the folders are created, the files belonging to each level are also generated. See Image 7 to check an graphic representation. Image 7: Generate struct representation","keywords":"","version":"Next"},{"title":"📌 Project Development Plan","type":0,"sectionRef":"#","url":"/leds-tools-public/oraculo/project_managment","content":"","keywords":"","version":"Next"},{"title":"📋 Backlog​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-backlog","content":" ID\tTeam\tFeature\tDescription\tImportance\tProposal1\tManagement\tPMC &amp; Documentation\tCreate the initial project documentation and PMC structure.\t95\tImprove documentation clarity 2\tManagement\tTechnology Research &amp; Metrics\tResearch suitable technologies and define performance metrics.\t90\tEnhance metric-based decision making 3\tManagement\tMetric Results\tCollect, analyze, and document project metrics throughout development.\t85\tImprove performance tracking 4\tManagement\tAutomated Reports\tGenerate and document automated metrics and performance reports.\t80\tReduce manual effort and errors 5\tDevelopers\tArchitectural Documentation\tDocument the system architecture to guide the development phase.\t95\tImprove development alignment 6\tDevelopers\tTechnology Implementation\tImplement technologies previously discussed and approved.\t90\tSpeed up development cycle 7\tDevelopers\tCode Improvement &amp; Docs\tRefactor code, enhance documentation, and ensure alignment with best practices.\t85\tImprove code quality and maintainability 8\tDevelopers\tFunctional App\tDeliver the fully functional and documented application, ready for deployment.\t100\tEnsure delivery of project goal    ","version":"Next","tagName":"h2"},{"title":"🧩 Project Model Canvas​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-project-model-canvas","content":" ","version":"Next","tagName":"h2"},{"title":"🔍 Justifications​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-justifications","content":" LEDS mentors have difficulty discovering the efficiency of students in completing tasks.Students lack a platform to check tasks and have them assigned.The repository analysis process is time-consuming when done manually.    ","version":"Next","tagName":"h3"},{"title":"🎯 Product​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-product","content":" A chatbot to assist in managing LEDS projects.    ","version":"Next","tagName":"h3"},{"title":"🧠 SMART Goal​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-smart-goal","content":" Collect data from GitHub repositories to create a chatbot that uses AI (Google Gemini) to provide real-time information about LEDS project progress in natural language.    ","version":"Next","tagName":"h3"},{"title":"✅ Requirements​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-requirements","content":" Friendly interface;Extract data from GitHub repositories;Automate analysis of team and individual performance.    ","version":"Next","tagName":"h3"},{"title":"🎁 Benefits​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-benefits","content":" Display team performance in sprint progress;Improve decision-making;Check individual performance metrics.    ","version":"Next","tagName":"h3"},{"title":"👥 External Stakeholders & Factors​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-external-stakeholders--factors","content":" Advisors, scholarship holders, staff, and other stakeholders involved in LEDS and FAPES.    ","version":"Next","tagName":"h3"},{"title":"🔮 Assumptions​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-assumptions","content":" Team commitment.Knowledge of the required technologies.    ","version":"Next","tagName":"h3"},{"title":"⚠️ Risks​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#️-risks","content":" 1. Requirement changes during the project​  Probability: 20%Mitigation: Ensure a solid requirements phase and allow flexibility in development to accommodate changes.  2. Lack of technical knowledge​  Probability: 60%Mitigation: Allocate time during sprints for learning and mastery.  3. Team member time constraints​  Probability: 80%Mitigation: Coordinate schedules and design viable sprints based on available time.    ","version":"Next","tagName":"h3"},{"title":"👥 Team​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-team","content":" 🧭 Management:​  Ana Júlia Caetano (Dominance)Caio Lessa (Compliance)Davidson Santos (Steadiness)Thiago Borges (Compliance)  🛠️ Developers:​  Alicia Caporalli (Steadiness)Lívia Hombre (Steadiness)Pedro Henrique Fonseca (Steadiness)Thiago Fabiano (Dominance)Vítor Nascimento (Compliance)    ","version":"Next","tagName":"h3"},{"title":"🧱 Team Topology​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-team-topology","content":" Platform Team Enables stream-aligned teams to deliver work autonomously. While stream-aligned teams maintain full ownership of their work, the platform team provides internal services and tools to support delivery.    ","version":"Next","tagName":"h3"},{"title":"📦 Deliverables​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-deliverables","content":" Management:​  Sprint 1: PMC and documentationSprint 2: Technology research and metric definitionSprints 3, 4, 5, 6: Results with collected metricsSprints 7 and 8: Automated metrics and performance report  Developers:​  Sprint 1: Architectural documentationSprint 2: Implementation of discussed technologiesSprints 3, 4, 5: Code improvements and documentationSprints 7 and 8: Functional and documented application    ","version":"Next","tagName":"h3"},{"title":"⛓ Constraints​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-constraints","content":" Must use OpenWebUI, FastAPI, Airbyte, PostgreSQL, and Gemini (via MyVanna)Dependent on AWS Marketplace / VSC environmentDelivery deadline: 3 months    ","version":"Next","tagName":"h3"},{"title":"🗓 Timeline​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-timeline","content":"     ","version":"Next","tagName":"h3"},{"title":"💰 Costs​","type":1,"pageTitle":"📌 Project Development Plan","url":"/leds-tools-public/oraculo/project_managment#-costs","content":" Team effort: R$1,000.00 × 9 members = R$9,000.00Transportation (3 months): R$4.90 × 60 days × 9 members = R$2,646.00Food: R$12.00 × 60 days × 9 members = R$6,480.00Team mental health: R$0.00  Total: R$18,126.00​   ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/theBottomLayerOverview","content":"","keywords":"","version":"Next"},{"title":"Src (Source)​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/theBottomLayerOverview#src-source","content":" The Src folder is automatically generated by a Langium project. It contains the most essential information and definitions of Spark.  ","version":"Next","tagName":"h2"},{"title":"Test​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/theBottomLayerOverview#test","content":" This folder is responsible for maintaining and structuring the Spark tests to ensure the integrity and accuracy of the generated code. ","version":"Next","tagName":"h2"},{"title":"Clean Architecture Csharp","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#layered-architecture","content":" The project follows Clean Architecture principles, with independent layers that isolate business rules, application logic, infrastructure, and user interface. Each layer only depends on the one below it, enabling low coupling and high cohesion.    ","version":"Next","tagName":"h2"},{"title":"Domain Layer — Moranguinho.Domain​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#domain-layer--moranguinhodomain","content":" This layer represents the core domain of the system, containing entities, business rules, and fundamental contracts.  Entities/ — Domain Entities​  Contains core entities like Agricultor, Propriedade, etc. Each entity encapsulates specific business behavior such as CPF validation or property area constraints.  Enums/ — Enumerations​  Defines fixed types used in the domain, contains baseEnum.cs.  Interfaces/ — Repository/Service Contracts​  Defines interfaces like IAgricultorRepository, IValidadorPropriedade, enabling dependency inversion and isolated testing.  Validation/ — Validation Rules​  Contains specific validation rules applied directly to entities or value objects.  Common/ — Abstractions and Utilities​  Base classes like BaseEntity, can contain abstractions and utilities.    ","version":"Next","tagName":"h3"},{"title":"Application Layer — Moranguinho.Application​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#application-layer--moranguinhoapplication","content":" Responsible for orchestrating system use cases and bridging presentation and domain layers.  UseCase/ — Use Cases​  Implements application processes like CriarAgricultor, BuscarPropriedadePorId, etc. Receives DTOs from the API and interacts with the domain and repositories. Example: BaseCase.cs.  Services/ — Application Services​  Auxiliary services used by use cases, such as productivity calculations or mapping utilities. Example: BaseService.cs, AgricultorService.cs.  DTOs/ — Data Transfer Objects​  Input and output objects for the application. Example folders: Request/, Response/, and Common/. Files: AgricultorRequest.cs, PropriedadeResponse.cs, etc.  Mappers/ — Object Converters​  Converts between domain entities and DTOs. Manual mapping used in files like AgricultorMapper.cs, PropriedadeMapper.cs.  Interfaces/ — Infrastructure Contracts​  Interfaces for services such as email sending, authentication, and repositories. Implemented in the Infrastructure layer.  Security/ — Security Abstractions​  Rules and contracts for authentication/authorization.  Configuration/ServiceExtensions.cs​  Registers all application services and configurations in the DI container.    ","version":"Next","tagName":"h3"},{"title":"Infrastructure Layer — Moranguinho.Infrastructure​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#infrastructure-layer--moranguinhoinfrastructure","content":" Contains concrete implementations of services and repositories, integrating with external systems like databases, security, etc.  Context/AppDbContext.cs​  EF Core DbContext implementation responsible for database access and entity mappings.  EntitiesConfiguration/​  Fluent API configuration for database mapping. Example: AgricultorConfiguration.cs, PropriedadeConfiguration.cs.  Repositories/​  Implements repositories defined in the domain. Examples: AgricultorRepository.cs, PropriedadeRepository.cs, and base implementations in Common/.  Security/​  Concrete implementations for security concerns, such as UserRepository.cs, RoleRepository.cs under Security/Repositories/.  ServiceExtensions.cs​  Registers infrastructure-level services into the DI container.    ","version":"Next","tagName":"h3"},{"title":"Presentation Layer — Moranguinho.WebAPI​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#presentation-layer--moranguinhowebapi","content":" The system's HTTP entry point, where requests arrive and are translated into application commands.  Controllers/​  Exposes API endpoints like POST /agricultores, GET /propriedades. Controllers: AgricultorController.cs, PropriedadeController.cs.  Extensions/​  Configuration for middleware, CORS, Swagger, authentication, etc. Files include JwtExtension.cs, CorsPolicy.cs, OData.cs.  Program.cs​  Application bootstrap file. Initializes the host, configures services, and defines the HTTP pipeline.  appsettings.json​  Configuration file for database connections, JWT keys, CORS, and API settings.  Scripts/​  Utility SQL scripts such as delete.sql, killdatabase.sql for local development or test resets.    ","version":"Next","tagName":"h3"},{"title":"Testing Layer — Moranguinho.Domain.Test and Moranguinho.Infrastructure.Test​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#testing-layer--moranguinhodomaintest-and-moranguinhoinfrastructuretest","content":" Dedicated layers for automated tests.  Moranguinho.Domain.Test​  Unit tests for domain entities and business rules. Focused on validation, behavior, and isolated logic. Files: AgricultorTest.cs, PropriedadeTest.cs.  Moranguinho.Infrastructure.Test​  Integration tests for repository behavior using EF InMemory. Files in Repositories/: AgricultorRepositoryTest.cs, PropriedadeRepositoryTest.cs. Includes appsettings.json and xunit.runner.json for test environment setup.  Testing framework: xUnit.    ","version":"Next","tagName":"h3"},{"title":". References​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#-references","content":" .NET - Usando a Clean Architecture - Jose Carlos MacorattiGithub CleanArchitecture - jasontaylordevGithub Clean Architecture Template - amantinband    ","version":"Next","tagName":"h2"},{"title":". Improvement Points​","type":1,"pageTitle":"Clean Architecture Csharp","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Clean#-improvement-points","content":" Clearer Layer Separation: Ensure distinct responsibilities for each layer, avoiding overlap of concerns between the Application, Domain, and Infrastructure layers. Use of AutoMapper: Implement AutoMapper or similar libraries to simplify and automate the mapping between domain entities and DTOs, reducing boilerplate code and improving maintainability. ","version":"Next","tagName":"h2"},{"title":"Django Project Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Python","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Python#layered-architecture","content":"   The project follows a modular, domain-driven layered architecture. This structure facilitates the separation of responsibilities, system scalability, and ease of maintenance and testing. Below, we detail each layer and component with examples of their responsibilities.  ","version":"Next","tagName":"h2"},{"title":"Domain Layer — apps/moranguinho/​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Python#domain-layer--appsmoranguinho","content":" This folder represents a Django application specific to a system domain: the management of farmers and properties. Each functionality related to this domain is grouped here, promoting modularity and functional cohesion.  models.py — Data Models​  The models represent the core entities of the system, such as Farmer and Property. Each model is linked to a database table, and its attributes reflect the table's columns. Business rules related to data behavior may also be included here.  api_views.py — API Controllers​  This file contains the interfaces that handle REST API requests. These controllers receive user requests, delegate logic to appropriate layers, and return responses. Examples include listing farmers, creating properties, and updating records.  serializers.py — Serialization and Validation​  Serializers convert Python objects into formats like JSON and handle both automatic and custom data validation. They act as an intermediary between database records and user-facing responses.  pagination.py, utils.py, signals.py — Supporting Features​  pagination.py: Manages pagination of list views.utils.py: Contains reusable utility functions (e.g., formatting, calculations).signals.py: Handles automatic actions triggered by events (e.g., creation of a new farmer).  test/ and features/ — Testing Layer​  test/: Contains unit and integration tests for component isolation.features/: Stores behavior-driven development (BDD) tests using Gherkin to simulate user behavior.  migrations/ — Database Version Control​  This folder includes Django migration files that track changes to the database schema over time, enabling safe evolution of the data model.  ","version":"Next","tagName":"h3"},{"title":"Global Project Settings — morango/​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Python#global-project-settings--morango","content":" This directory contains the core configuration files of the Django project.  settings.py: Defines project-wide settings such as database configuration, installed apps, middleware, and REST framework settings.urls.py: Defines main routes for the API and Django admin panel.wsgi.py and asgi.py: Handle communication between web servers and the application.    ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Python#references","content":" Django Official DocumentationDecoding DDD: A Three-Tiered Approach to Django Projects – DjangoCon US    ","version":"Next","tagName":"h2"},{"title":"Improvement Points​","type":1,"pageTitle":"Django Project Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Python#improvement-points","content":" Project with growth potential: Split the moranguinho app into multiple smaller apps, such as farmers, properties, and reports. Each app would target a specific subdomain, improving maintenance, cohesion, and testability. ","version":"Next","tagName":"h2"},{"title":"C# Minimal API Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#layered-architecture","content":" The backend follows a modular layered architecture, organizing components by domain and functionality. Each layer has a defined responsibility, as shown below:    ","version":"Next","tagName":"h2"},{"title":"Presentation Layer​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#presentation-layer","content":" Located in the Webservice/ folder.  Contains the Program.cs file, responsible for configuring and exposing HTTP routes, middlewares (Swagger, CORS, authentication), and app services.Acts as the UI of the API, handling direct interaction with clients.  ","version":"Next","tagName":"h3"},{"title":"Domain Layer​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#domain-layer","content":" Located in the Moranguinho/ folder.  Includes domain-specific logic and models such as Agricultor.cs, Propriedade.cs, and ContextDbFactory.cs.Organizes code by feature, improving maintainability and separation of concerns.  ","version":"Next","tagName":"h3"},{"title":"Shared Layer​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#shared-layer","content":" Located in the Shared/ folder.  Provides cross-cutting utilities and shared components like models, enums, and helper classes.Contains the ContextDb/ subfolder, which handles database access using EF Core (Entity Framework Core).  This structure enables a clean separation between domain logic, infrastructure, and service exposure.    ","version":"Next","tagName":"h3"},{"title":"Main Folders​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#main-folders","content":" ","version":"Next","tagName":"h2"},{"title":"Webservice​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#webservice","content":" Service exposure layer of the application.  Program.cs​  Initializes and configures the Minimal API app, sets up services, middlewares, and routes.  Endpoints and Middleware​  Responsible for exposing routes to external consumers, including Swagger setup, CORS policy, and authentication (if applicable).    ","version":"Next","tagName":"h3"},{"title":"Moranguinho​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#moranguinho","content":" Represents the core domain logic.  Agricultor.cs​  Defines the Agricultor entity and related domain logic.  Propriedade.cs​  Represents the Propriedade entity, modeling the domain structure for rural properties.  ContextDbFactory.cs​  A factory class used to instantiate the DbContext, especially useful for dependency injection or testing scenarios.    ","version":"Next","tagName":"h3"},{"title":"Shared​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#shared","content":" Shared resources and infrastructure.  ContextDb/​  Contains:  DbContext definition used by EF CoreEntity configurations and model mappingsResponsible for database interaction (CRUD operations, migrations, etc.)  Used across the entire application to maintain a centralized and consistent data access approach.    ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#references","content":" https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apishttps://www.infoq.com/articles/minimal-api-dotnet6/https://learn.microsoft.com/en-us/ef/core/    ","version":"Next","tagName":"h2"},{"title":"Improvement Points​","type":1,"pageTitle":"C# Minimal API Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Csharp_Minimal-API#improvement-points","content":" Add Service Layer (optional): Including a service layer between endpoints and domain classes could improve the separation of business logic.Program.cs too big: Create the service layer, and routes configurations ","version":"Next","tagName":"h2"},{"title":"Java Spark Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java","content":"","keywords":"","version":"Next"},{"title":"Layered Architecture​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#layered-architecture","content":" Backend development in Java was structured in layers, organizing the system in hierarchies, each with its own responsibilities. The division was made as follows:    ","version":"Next","tagName":"h2"},{"title":"Data Layer​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#data-layer","content":" Responsible for entities and repositories (entity/ folder).  ","version":"Next","tagName":"h3"},{"title":"Application/API Layer​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#applicationapi-layer","content":" Includes controllers and exposed services (webservice/ folder).  This structure facilitated maintenance, testability, and the reuse of components.    ","version":"Next","tagName":"h3"},{"title":"Main Folders​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#main-folders","content":" ","version":"Next","tagName":"h2"},{"title":"Entity​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#entity","content":" models/​  Contains Java classes corresponding to entities defined in the .spark file (e.g., Agricultor, Propriedade). These entities reflect database tables and include JPA annotations.  repositories/​  Database access interfaces such as AgricultorRepository.java, which extend JpaRepository and are used for queries.  sql/​  SQL scripts useful for data replication setup and database constraint creation.  register/​  Stores project metadata, such as the morango-register.json file, which registers information about created modules and entities.  resources/​  Application configuration files such as application.properties, containing Spring Boot configurations.  ","version":"Next","tagName":"h3"},{"title":"Webservice​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#webservice","content":" Service exposure layer of the application. This is where application logic interfaces with the outside world (frontend or API consumers).  application/​  Contains the Application.java class that initializes the Spring Boot project.  controllers/​  REST/GraphQL controllers generated for each entity. Handle requests and define endpoints.  records/​  DTOs (Data Transfer Objects), which carry input and output data of the API. Example: AgricultorInput.java.  repositories/​  Serve as adapters between controllers and domain-layer repositories.  resources/graphql/​  Contains the schema.graphqls file, which defines the types, queries, and mutations of the GraphQL API, based on the entities defined in the .spark file.    ","version":"Next","tagName":"h3"},{"title":"References​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#references","content":" https://www.alura.com.br/artigos/padroes-arquiteturais-arquitetura-software-descomplicadahttps://jeziellago.medium.com/padr%C3%B5es-de-arquitetura-de-software-parte-i-a1d23c323a40    ","version":"Next","tagName":"h2"},{"title":"Improvement Points​","type":1,"pageTitle":"Java Spark Architecture","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/backend/Java#improvement-points","content":" Better naming of web repositories: AgricultorRepositoryWeb.java can be confused with AgricultorRepository.java. More specific names like AgricultorGraphQLAdapter would prevent such issues we encountered during analysis.Creation of a service layer: Adding an intermediate layer between controllers and repositories with pure business logic would increase separation of concerns. ","version":"Next","tagName":"h2"},{"title":"Motivation","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/componentBasedArchitecture","content":"Before proceeding with the explanation of the specific architectures implemented, we must introduce the component-based architecture. Motivation In the early days of the internet, web applications and websites were developed in a static manner, meaning with little to no dynamically generated pages. The holy trinity—Hypertext Markup Language (HTML), Cascading Style Sheets (CSS), and JavaScript (JS)—was not used with the concern that it should update on its own without the need for server-side preprocessing of the pages. Therefore, languages like Hypertext Preprocessor (PHP) were used in monolithic structures, linking the frontend with the database through preprocessing. As time passed, the internet grew in importance, and many devices, particularly smartphones, needed to access it. Due to differences in screen sizes and compatibility, in order for a person using a mobile device to access a website with quality, it was often necessary to reimplement parts of the business logic in the responsive modules of the system, greatly increasing development costs. Thus, a migration process began from the monolithic structure to the separation of the frontend and backend, where the latter is mostly configured as a REST API. With the formal division between backend and frontend, the creation of responsiveness for a website to work on both computers and mobile devices no longer influences business logic; everything is contained in a single place. There are various ways to develop a frontend, and due to the difficulty of working solely and exclusively with the holy trinity, there was still a need for preprocessing HTML. Additionally, pure HTML, CSS, and JS do not provide built-in, easy-to-use tools for code reuse. Therefore, there was a need for a resource or concept to address all of the aforementioned issues. Components: One of the Possible Solutions Several proposals have been made to meet the demands of frontend development. One of the most successful is the use of components. It’s hard to say which tool implemented this feature first, but one of the most influential frameworks to adopt a component-based structure was React, which is still widely used today. Many other frameworks that came after React, such as Vue, Angular, and Next, also implement components, and all follow a very similar architecture. For this reason, we need to first understand the architecture from a general perspective before diving into specifics. What is a Component? A component is essentially a reusable piece of code that expands into HTML within another section of HTML. This feature is typically implemented through an abstraction of HTML that is preprocessed and then returned as raw HTML. Let’s take React as an example. In React, components are defined as the return value of a function, and that return is typically a string (or a JSX structure) containing HTML tags. Once a component function is defined, it can be imported into another file and used as if it were a native HTML tag within the return of another component. Here’s a code example: File1.jsx const ComponentName = () =&gt; { return ( &lt;&gt; &lt;span&gt;Hello World 1&lt;/span&gt; &lt;span&gt;Hello World 2&lt;/span&gt; &lt;/&gt; ); }; export default ComponentName; File2.jsx import ComponentName from &quot;path/to/component/File1.jsx&quot;; const OtherComponent = () =&gt; { return ( &lt;&gt; &lt;ComponentName /&gt; &lt;/&gt; ); }; Resulting HTML &lt;span&gt;Hello World 1&lt;/span&gt; &lt;span&gt;Hello World 2&lt;/span&gt; This is how HTML is used in React. Now notice — every HTML code in React is used in the form of a component, meaning everything is a component. Despite that, there is an informal division among components. Typically, the term component refers to a piece of code that is reused across multiple parts of the project. However, there are also components that serve a specific, single purpose. These specific components are commonly referred to as pages, templates, or views — depending on the author’s preference. Generalizing the Architecture With the foundational understanding of component-based architecture, all other architectures will generally follow a similar pattern regardless of the framework used. Typically, there is one folder for reusable components and another for pages, both located within a larger folder that contains the main source code files (usually named src in frameworks based on NodeJS). In addition, there is always some form of HTML abstraction and a way to import components into one another. Other functionalities, such as route configuration, API communication, and so on, are more flexible—although there are common implementation patterns and recommendations, they are not strictly defined.","keywords":"","version":"Next"},{"title":"Vue Plus Vuetfy","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy","content":"","keywords":"","version":"Next"},{"title":"1.1 Vue VS Vuetfy VS Vite​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#11-vue-vs-vuetfy-vs-vite","content":" The generated frontend relies on the participation of three main frameworks: Vue, Vuetify, and Vite.  Vue is the primary framework, meaning it is the most important in this list. It is responsible for component management, HTML preprocessing, object reactivity control, and more. Other frameworks and libraries can emerge from Vue, each serving a specific purpose.  Vuetify is one of these tools that emerge from Vue. It is essentially a collection of ready-to-use, reusable components, complete with a set of properties and useful features.  Lastly, Vite is an external tool used to optimize the development and build process of the project. With Vite, when editing code, a hot update is performed in real-time, applying only the changes made, which speeds up the development process. Additionally, when building the project, the site is optimized by Vite.    2. The Architecture    The project is divided into three layers: src, public, and cypress.  The public layer contains static files used in development.The cypress layer is responsible for containing the code that generates the basic pages for each entity — currently, it includes pages for listing, viewing, updating, creating, and deleting entities.The src folder contains the actual page files and scripts — the core of the frontend.  2.1 Src Folder    ","version":"Next","tagName":"h2"},{"title":"2.2 Router​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#22-router","content":" The router folder contains the configuration for the vue-router extension, which is responsible for managing the frontend endpoints. Currently, it has a single file that centralizes all the application's routes, but it is possible to break it up into separate files for smaller files and better organization.  ","version":"Next","tagName":"h2"},{"title":"2.3 Views​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#23-views","content":" This layer is responsible for containing the application's page components. Within it, there is a subdivision based on the packages defined in the Spark model. Inside each package, the defined entities have separate folders, each containing the reference files IndexEntity.vue, FormIndex.vue, and DetailsIndex.vue. These pages, together, automatically enable the basic operations for each entity (CRUD). The view layer can also consume the SCSS layer directly.  ","version":"Next","tagName":"h2"},{"title":"2.5 Service plus Composition​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#25-service-plus-composition","content":" The service layer is responsible for managing the HTTP requests from the frontend. With the help of a Factory, a series of EntityRequires files are created, each generating a set of requests defined in the composition/usesApi.ts file — including create, update, remove, list, and getById. In each EntityRequires, the basic endpoint URL for the entity's operations is hardcoded, which is then combined by the factory with the base URL of the API (the backend URL).  ","version":"Next","tagName":"h2"},{"title":"2.6 Components​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#26-components","content":" The components layer is intended to store components that can be reused across multiple pages. Currently, a Breadcrumbs component is generated, which helps the user navigate the site, indicating the navigation path at the top of the screen and providing a sidebar for navigation.    Image 7: Frontend Example. At top screen, the Breadcrumbs component.  ","version":"Next","tagName":"h2"},{"title":"2.7 SCSS and Layouts​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#27-scss-and-layouts","content":" The SCSS folder stores SCSS files (a variant of CSS) for custom styles that are shared across pages when needed. The layouts layer, on the other hand, contains configuration for the layout of certain elements throughout the application. As an example, the sidebar configuration is handled internally within the layouts folder. It can also be used to manage responsive behavior across the application.  ","version":"Next","tagName":"h2"},{"title":"2.8 Utils​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#28-utils","content":" The utils folder contains scripts that are used in various parts of the code but do not belong to a specific context. Simple functions for text manipulation or global configurations reside in the utils folder.  ","version":"Next","tagName":"h2"},{"title":"2.9 Plugins​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#29-plugins","content":" The plugins folder contains the configuration of external plugins used in the application. In this case, only Vite is used, so it is the only one present in this folder. Any new external plugin configurations should be added here.  ","version":"Next","tagName":"h2"},{"title":"2.10 Stores​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#210-stores","content":" The stores layer is responsible for storing configurations locally in the client's browser. For example, authentication cookie settings are handled here.  ","version":"Next","tagName":"h2"},{"title":"2.11 Theme​","type":1,"pageTitle":"Vue Plus Vuetfy","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy#211-theme","content":" The theme layer contains the application's color configuration. It is loaded by Vue itself and applies color styling across all layers of the application.  3. Suggestions for Improvements:  The view files are very large. In a single file, both interface control and entity manipulation are handled. It is preferable that for each page, a corresponding script be created to handle the entities, and the .vue file should deal only with the interface.  The routes file is very large. It would be better to create a folder for each module, and each entity should have its own routes file to make searching and reading easier.  The pages make little use of request interface definitions from each other. It would be better to have a layer to centralize the Data Transformation Objects from requests into JS objects.  Request handling is being done in a decentralized manner. It would be better to have a layer to configure and manage the requests and entities, while the views focus on displaying this data on the screen and calling these actions when necessary. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/introduction","content":"Introduction Spark generates code for both the backend and the frontend. In the following sections, we will discuss how the code for both parts of the software is developed.","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Architecture/understandTopLayer","content":"","keywords":"","version":"Next"},{"title":"Bin​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/understandTopLayer#bin","content":" This folder, normally used to store machine-compiled code, is responsible for containing the files that manage the execution of the available commands. These files are most likely executed via the Command Line Interface (CLI). Since the project is developed with NodeJS, it's possible to use JavaScript (JS) source code to access the system’s operating system calls (SCs). Therefore, there is no need for compiled code in this folder; all files here are JS source code, but their purpose is the same as that of a folder containing binary files.  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/understandTopLayer#examples","content":" The examples folder contains files in the Spark format (.spark) with examples demonstrating how the tool's syntax works.  ","version":"Next","tagName":"h2"},{"title":"Images​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/understandTopLayer#images","content":" This folder contains images used in the repository’s documentation and in the tool’s documentation within VSCode. It is a folder with static files.  ","version":"Next","tagName":"h2"},{"title":"Models​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/understandTopLayer#models","content":" This folder is responsible for part of the documentation. It contains files that model the tool's reserved keywords and how they communicate and interact, using the Unified Modeling Language (UML).  The files are in the .vpp format, which is read by the Visual Paradigm tool. The files in question were created with an unidentified version of the tool. Image 3 shows the internal content of the only file present in the folder, opened in the most recent version of the tool as of now, version 17.2. Therefore, it is not guaranteed that the internal content in the image is complete.    Image 3: reserved keywords and how they communicate and interact  ","version":"Next","tagName":"h2"},{"title":"Scripts​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/understandTopLayer#scripts","content":" This folder is responsible for containing some code that will potentially be called by the bin folder but is not part of the CLI. Currently, its files are responsible for preparing the environment with the folder structure, ensuring that the generation of subsequent files does not encounter errors.  ","version":"Next","tagName":"h2"},{"title":"Static​","type":1,"pageTitle":"Overview","url":"/leds-tools-public/spark/Architecture/understandTopLayer#static","content":" This folder is automatically generated by a Langium project along with Monaco to create static documentation for the tool under development. Since the documentation is now being created separately with an external tool, namely Docusaurus, it has been discontinued and no longer receives updates. ","version":"Next","tagName":"h2"},{"title":"How to Use","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/howtouse","content":"How to Use (Prerequisite): Ensure that the Leds - Spark - Beta extension is installed in your VSCode editor. This extension is available through the editor's built-in extension marketplace. It is required to leverage Spark's features without the need to import libraries locally into your project. Note that it differs from the Spark - LEDS extension, which is also available in the same marketplace. Unlike the latter, Leds - Spark - Beta relies on an external library that unifies backend and frontend generation with a greater decoupling of responsibilities from Langium. The library, in turn, is responsible for decoupling business logic from the extension’s core repository, enabling reuse without compromising the main generation functionality.Create a file with extension .spark (e.g., slave_one.spark)Define the class diagramSave the file .sparkClick with right botton and chose one optionAfter that, Spark will generate the software artifacts","keywords":"","version":"Next"},{"title":"Installation","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/installation","content":"Installation To install Spark, follow these steps: Open Visual Studio CodeClick on ExtensionsSearch for SparkClick to install the Spark extension by LEDS IFES","keywords":"","version":"Next"},{"title":"Factory Method Pattern in the Project Structure","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Creational-Patterns/Factory-Method","content":"","keywords":"","version":"Next"},{"title":"Structure I Implemented​","type":1,"pageTitle":"Factory Method Pattern in the Project Structure","url":"/leds-tools-public/spark/Creational-Patterns/Factory-Method#structure-i-implemented","content":" The structure is composed of 4 main parts:  ","version":"Next","tagName":"h2"},{"title":"1. Abstract Class: AbstractGeneratorFactory​","type":1,"pageTitle":"Factory Method Pattern in the Project Structure","url":"/leds-tools-public/spark/Creational-Patterns/Factory-Method#1-abstract-class-abstractgeneratorfactory","content":" I created a base class called AbstractDocumentationGeneratorFactory, which defines a method generate(). This method:  Creates the folder where the files will be generated.Calls an abstract method called createGenerators() — which is the actual factory method.Then, executes the generate() method of each returned generator.  This generate() method controls the common generation flow, and I didn’t have to repeat this logic for each generator type.    ","version":"Next","tagName":"h3"},{"title":"2. Factory Method: createGenerators()​","type":1,"pageTitle":"Factory Method Pattern in the Project Structure","url":"/leds-tools-public/spark/Creational-Patterns/Factory-Method#2-factory-method-creategenerators","content":" This method is abstract and implemented by the subclasses. Each subclass represents a specific &quot;factory&quot;, such as:  StandardDocumentationGeneratorFactory – responsible for generating documentation files.In other parts of the project, I have factories that generate entities or webservices as well.  Each factory knows which concrete generators it needs to instantiate.    ","version":"Next","tagName":"h3"},{"title":"3. Common Interface: IJavaGenerator​","type":1,"pageTitle":"Factory Method Pattern in the Project Structure","url":"/leds-tools-public/spark/Creational-Patterns/Factory-Method#3-common-interface-ijavagenerator","content":" All my concrete generators implement the IJavaGenerator interface, which requires them to have a generate(model, targetFolder) method. This ensures that any generator, regardless of what it produces, can be used interchangeably.    ","version":"Next","tagName":"h3"},{"title":"4. Concrete Generators​","type":1,"pageTitle":"Factory Method Pattern in the Project Structure","url":"/leds-tools-public/spark/Creational-Patterns/Factory-Method#4-concrete-generators","content":" I have several concrete classes that handle the actual file generation. One example is DocumentationGenerator, which creates files like README.md and .gitlab-ci.yml. But I also have generators like EntityGenerator, ControllerGenerator, among others. ","version":"Next","tagName":"h3"},{"title":"Front-end Architecture","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/frontend_architecture","content":"","keywords":"","version":"Next"},{"title":"Generators​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/frontend_architecture#generators","content":" The generators, in TypeScript, creates the code, the files and the folders of the frontend.  The generators are organized acordingly with what they create.  The generators on the superiors parts create the structure and call the generators in the level below them. This generators will create a specific part of the code and the respective files and/or will create other folders and call their respective generators.  ","version":"Next","tagName":"h2"},{"title":"Generator's Organization​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/frontend_architecture#generators-organization","content":" ","version":"Next","tagName":"h2"},{"title":"Main Generator​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/frontend_architecture#main-generator","content":" Creates the App.vue and configuration files. Vue's main file.Calls the router (src/router). Creates the cypress folder.Creates the public folder.Creates the src folder.  ","version":"Next","tagName":"h3"},{"title":"frontend/cypress​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/frontend_architecture#frontendcypress","content":" Folder with subfolders responsible for generating the structure of Cypress, an automated front-end testing tool.  e2e: Defines the tests that are going to be made.PageObjects: Applies the Page Object Pattern, organizing and encapsulating page elements and actions into reusable components.  ","version":"Next","tagName":"h3"},{"title":"frontend/public​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/frontend_architecture#frontendpublic","content":" Defines the public assets for the project, like the favicon image, environment variables and redirect configs.  ","version":"Next","tagName":"h3"},{"title":"frontend/src​","type":1,"pageTitle":"Front-end Architecture","url":"/leds-tools-public/spark/frontend_architecture#frontendsrc","content":" Folder with multiple subfolders. Each subfolder is responsible for part of the frontend components.  Components: Defines the options for colors. Composition: Defines the available funcionabilities (e.g.: get by id, post, delete). Layout: Defines the components disposition on the screen. Plugins: Imports Vuetify to style the components and define the default theme. Router: Defines the routes for src/composition. Scss: Defines the components used in src/layout. Services: Generates the Factory and the Api (localhost port). Stores: Makes the user configurations (e.g.: authentication, followers, posts) Theme: Defines the colors to light theme and dark theme. Utils: Defines colors used in each theme. Views: src/views/model: Create the responsible files for the Index, Detail and Form screens to each class. src/views/authentication: Create the responsible file for the user sidebar login. ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Lib/OverView","content":"Overview In order to modularize, generate reuse and simplify the understanding of the Spark source code, we created a lib that does all the processing of the back-end generations. We moved the entire concept of back-end generators that was previously done within Spark into the spark-generators-lib lib, leaving only one file within each respective folder within Spark, just referencing the lib call and maintaining the processing.","keywords":"","version":"Next"},{"title":"Understanding the Language","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/lang","content":"","keywords":"","version":"Next"},{"title":"Configuration​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#configuration","content":" This constructor allows you to define:  Software NameDescription about the softwareLanguage desired to develop the information systemDatabase name   Configuration { software_name: &quot;SlaveOne&quot; // Software's name about: &quot;Slave One project example&quot; // Description about the software language: python // Language and pattern used to develop the software database_name: &quot;SlaveOneDB&quot; // Database Name }   For the language, we have the options: python, java, csharp-minimal-api, csharp-clean-architecture.  ","version":"Next","tagName":"h2"},{"title":"Class Diagram​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#class-diagram","content":" Spark allows you to organize a class diagram into Modules. The declaration of a module follows this pattern:  module Main { // Components of the module go here }   Inside each module, it is possible to define Entities, relations between entities, and Enums.  entity Project { name: string start_date: date end_date: date budget: decimal client: string sponsor: string goal: string project_father OneToMany Project time OneToMany Time status uses Status } enum Status { Ativo Cancelado Entregue }   ","version":"Next","tagName":"h2"},{"title":"Attribute and Relationship Types​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#attribute-and-relationship-types","content":" Entities have attributes, and the available types are: string, integer, decimal, datetime, date, boolean, uuid, email, cpf, cnpj, zipcode, currency, mobilePhoneNumber, phoneNumber, file, void.  Spark allows the following relationships:  OneToOneOneToManyManyToOneManyToMany  ","version":"Next","tagName":"h2"},{"title":"Use Cases​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#use-cases","content":" Spark provides comprehensive support for modeling use cases, allowing the definition of actors, events, and relationships between use cases.  ","version":"Next","tagName":"h2"},{"title":"Defining Actors​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#defining-actors","content":" Actors represent entities or roles interacting with the system. An actor can optionally extend another actor and include attributes like name.  actor ProjectManager name: &quot;Project Manager&quot; actor TeamMember name: &quot;Team Member&quot;   ","version":"Next","tagName":"h3"},{"title":"Defining Use Cases​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#defining-use-cases","content":" A use case describes a functionality of the system. It can include actors, events, descriptions, and inheritance from other use cases.  usecase ManageProjects extends BaseUseCase { name: &quot;Manage Projects&quot; description: &quot;Handles project management functionalities&quot; performer: ProjectManager, TeamMember event CreateProject { name: &quot;Create a Project&quot; description: &quot;Allows the creation of a new project&quot; action: &quot;Create&quot; } event AssignTask { name: &quot;Assign a Task&quot; description: &quot;Assigns tasks to team members&quot; action: &quot;Assign&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Defining Events​","type":1,"pageTitle":"Understanding the Language","url":"/leds-tools-public/spark/lang#defining-events","content":" Events are integral components of a use case. They represent actions or operations, with optional dependencies on other events.  event CreateProject { name: &quot;Create a Project&quot; description: &quot;Initiates the creation of a project&quot; action: &quot;Create&quot; depend: AssignTask }   Where:  Actors are the performers of the use case.Use Cases define the system's functionality.Events represent discrete operations within a use case. ","version":"Next","tagName":"h3"},{"title":"SRC","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Lib/Src","content":"SRC With the use of the lib we needed to modify our source code of the spark generators, where all code generation logic was within the source code, with the use of our lib we removed all this part of the product logic and kept only the lib calls we created, keeping only one generator.ts within each respective language. This leaves us with the source code structure like this: These generators are where spark-generators-lib is called for each language, thus communicating with the generators and index within the lib.","keywords":"","version":"Next"},{"title":"Explanning","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Lib/Explanning","content":"Explanning To modularize, we copy the folder structure of the backend generators into our lib, in order to remove this part of the processing from within the main program. We created this directory structure We created the generators folder to make the calls uniform and in the same directory, this is necessary npm The final use of the lib is in referencing these generators folder The Shared folder was created due to the common need to use files that were also shared in the application within the original Spark structure. Index.ts is an extremely important part in the construction of our lib, it is where the logic imports are scaled between folders and referenced at the time of import for use in the source code.","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/overview","content":"Overview Spark allows to develope a information system on the following languagens, Architecture, and frameworks: Back-end: Python: Creates an API using Model-View-Controle implemented by Django;Java: Creates an API using Model-View-Controller implemented by Spring-Boot..Net: Creates an API using Model-View-Controller using Minimal API or Clean Architecture with CQRS. Front-end: Vue: create a visual components with Vue.js. Finally, Spark also creates: Documentation: Class Diagram Model, using Plant UML, and descroption of models and entities on Markdown.CI/CD: allow create the files that enable a CI/CD on GitLab.","keywords":"","version":"Next"},{"title":"Release Plan","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/release-plan","content":"","keywords":"","version":"Next"},{"title":"Version 1 for .NET​","type":1,"pageTitle":"Release Plan","url":"/leds-tools-public/spark/release-plan#version-1-for-net","content":" Estimated duration: 2 WeeksExpected delivery date: End of AugustFeatures: Tracing and Logging in .NET; Implement automated back-end tests + basic CRUD; Implement automated front-end tests + basic CRUD; Modifications suggested by the DEV team;  ","version":"Next","tagName":"h2"},{"title":"Version 2​","type":1,"pageTitle":"Release Plan","url":"/leds-tools-public/spark/release-plan#version-2","content":" Estimated duration: 4 WeeksExpected delivery date: SeptemberFeatures: Generation of authorization rules with OPA  ","version":"Next","tagName":"h2"},{"title":"Version 3​","type":1,"pageTitle":"Release Plan","url":"/leds-tools-public/spark/release-plan#version-3","content":" Estimated duration: 3 WeeksExpected delivery date: OctoberFeatures: Using AI Pipeline for inserting; Business Rules into domain classes (2 weeks); Inserting new attributes into existing classes (1 week);  ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/spark/project_managment#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tCreate authorization service rules based on Actor and User Case's Events\tCreate authorization rules on Back-End and Front-End based on relations among actors and User Case's Events\t100\tImprove software development process by 10% 2\tCreate authorization data rules based on Actor and User Case's Events\tCreate authorization data rules on Back-End and Front-End based on relations among actors and User Case's Events (Owner Patterns)\t95\tImprove software development process by 10% 3\tImplement Minimal API with M(domain, service)VC pattern\tApply M(domain, service)VC pattern using Minimal API approach in C#, Java, and Django projects\t90\tStandardize architecture to reduce rework 4\tFix document insertion error in Django\tIdentify and fix the issue preventing document insertion in Django\t85\tEnsure system integrity and functionality 5\tAdd missing library in Java project\tIdentify and integrate the required library to ensure proper execution of the Java project\t80\tEliminate technical blockers for the team 6\tFix general errors in Django\tResolve various backend issues in the Django project\t88\tReduce bugs and improve system stability 7\tGenerate classes based on use case type\tAutomate the creation (or not) of classes based on the use case type (e.g., CRUD or non-CRUD)\t82\tBoost productivity in software modeling 8\tGenerate code with AI based on use case comments\tUse AI to analyze comments and automatically generate supporting code\t93\tAccelerate development with intelligent assistance  ","version":"Next","tagName":"h2"},{"title":"General planning​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/spark/project_managment#general-planning","content":" Stopped development on creating OPA based on actor and use case events, without a link to C#.  Release 1.0 (14/10/2024 - 01/11/2024): Create authorization service rules based on Actor and User Case's Events on C# application and Create authorization data rules based on Actor and User Case`s Events (Owner Patterns) on C#  ","version":"Next","tagName":"h2"},{"title":"Release 1.0 - 01/11/2024​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/spark/project_managment#release-10---01112024","content":" Goal: Create authorization service and data based on User Case Diagram Features: ID 1 and ID 2 Deadline I - 25/10/2024 ID 1: Create authorization service rules based on Actor and User Case's Events on C# application Deadline II - 01/11/2024 ID 2: Create authorization data rules based on Actor and User Case`s Events (Owner Patterns) on C#  ","version":"Next","tagName":"h2"},{"title":"Metamodel","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/metamodel","content":"","keywords":"","version":"Next"},{"title":"Model​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#model","content":"   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#configuration","content":" Description: Represents the configuration settings of the system. This class is imported from the config package.Attributes: (Attributes are defined within the config package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"AbstractElement​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#abstractelement","content":" Description: An abstract representation of system elements. It serves as a base for more specific elements like Module and EnumX.Relationships: Inheritance: Module and EnumX inherit from AbstractElement.  ","version":"Next","tagName":"h3"},{"title":"ModuleImport​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#moduleimport","content":" Description: Represents an import statement for modules. This class is imported from the modules package.Attributes: (Attributes are defined within the modules package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Actor​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#actor","content":" Description: Represents an actor in the system, typically a user or external system that interacts with the system's use cases.Attributes: (Attributes are defined within the entities or usescases package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#usecase","content":" Description: Represents a use case within the system, defining a specific functionality or behavior that actors can perform.Attributes: (Attributes are defined within the usescases package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Module​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#module","content":" Description: Represents a module within the system, which can contain various elements such as other modules, enums, or local entities.Attributes: name: A QualifiedName that uniquely identifies the module.comment: An optional Comment providing additional information about the module.elements: A collection of AbstractElement or LocalEntity instances contained within the module. Relationships: Has: May contain one Comment.Contains: Can contain multiple AbstractElement and LocalEntity instances.  ","version":"Next","tagName":"h3"},{"title":"EnumX​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#enumx","content":" Description: Represents an enumeration within the system. Inherits from AbstractElement.Attributes: (Attributes specific to the enumeration are defined within the entities package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"LocalEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#localentity","content":" Description: Represents a local entity within a module. This could be a class, interface, or other construct defined within a module.Attributes: (Attributes are defined within the entities package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Comment​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#comment","content":" Description: Represents a comment within the grammar, providing additional context or explanations for modules.Attributes: content: A string containing the comment text.  ","version":"Next","tagName":"h3"},{"title":"QualifiedName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#qualifiedname","content":" Description: Represents a qualified name used to uniquely identify elements within the system. Imported from the terminals package.Attributes: (Attributes are defined within the terminals package and are not detailed here.)  ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#configuration-1","content":" This class diagram provides a clear and organized view of the Configuration class within the SPARK grammar, demonstrating how it integrates various fragments to encapsulate different aspects of the system's configuration. By using fragments such as DataBaseName, Language, PackagePath, and Features, the model promotes reusability and consistency, ensuring that common configuration patterns are maintained across different components of the system. The optional association between Features and Entity allows for enhanced flexibility, enabling features to be contextually linked to specific entities as needed.    ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#configuration-2","content":" Description: The Configuration class encapsulates the system's configuration settings. It includes various attributes that define the software's name, description, database configuration, package paths, programming language, and feature settings. Attributes: name: A string representing the name of the software.description: A string providing an overview or details about the software.dataBaseName: An instance of the DataBaseName fragment specifying the database name.packagePath: An instance of the PackagePath fragment specifying the package path.language: An instance of the Language fragment specifying the programming language used.features: An instance of the Features fragment defining various features of the software. Relationships: Includes: DataBaseName: Defines the name of the database.PackagePath: Specifies the package path used in the system.Language: Indicates the programming language employed.Features: Details the features available, optionally associating them with specific entities.  ","version":"Next","tagName":"h3"},{"title":"DataBaseName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#databasename","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Specifies the name of the database used by the system.Attributes: database_name: A string representing the database name.  ","version":"Next","tagName":"h3"},{"title":"Language​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#language","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Specifies the programming language used in the system.Attributes: language: An enumeration (LANGUAGETYPE) representing the programming language (e.g., Java, Python).  ","version":"Next","tagName":"h3"},{"title":"PackagePath​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#packagepath","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Specifies the package path used in the system.Attributes: package_path: An enumeration (LANGUAGETYPE) representing the package path.  ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#features","content":" Stereotype: &lt;&lt;fragment&gt;&gt;Description: Defines features of the system, optionally associating them with specific entities.Attributes: feature: An enumeration (FEATURE_TYPE) representing the type of feature.entity: An optional reference to an Entity using a QualifiedName.  ","version":"Next","tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#entity","content":"   ","version":"Next","tagName":"h2"},{"title":"Entity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#entity-1","content":" Description: The Entity interface is implemented by both LocalEntity and ImportedEntity. This allows these classes to be treated uniformly when establishing relationships and dependencies.Inheritance: LocalEntity ..|&gt; EntityImportedEntity ..|&gt; Entity  ","version":"Next","tagName":"h3"},{"title":"ModuleImport​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#moduleimport-1","content":" Description: Represents an import statement for modules. It specifies the package path, library, module name, and the entities being imported.Attributes: package_path: The path of the package as a string.library: The name of the library from which modules are imported.name: The name of the module.entities: A list of ImportedEntity instances representing the entities being imported. Relationships: Imports: Can import multiple ImportedEntity instances.  ","version":"Next","tagName":"h3"},{"title":"ImportedEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#importedentity","content":" Description: Represents an entity that is imported into a module. It holds the name of the entity.Attributes: name: The name of the imported entity.  ","version":"Next","tagName":"h3"},{"title":"LocalEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#localentity-1","content":" Description: Represents a local entity within a module. This could be a class, interface, or other construct defined within a module.Attributes: name: The name of the entity.superType: An optional reference to another Entity that this entity extends.is_abstract: A boolean flag indicating whether the entity is abstract.attributes: A collection of Attribute instances defining the entity's attributes.enumEntityAttributes: A collection of EnumEntityAtribute instances.relations: A collection of Relation instances defining relationships with other entities.functions: A collection of FunctionEntity instances defining the entity's functions. Relationships: Inherits: Implements the Entity interface.Contains: Can contain multiple Attribute, EnumEntityAtribute, Relation, and FunctionEntity instances.Has: May have an optional Comment.  ","version":"Next","tagName":"h3"},{"title":"FunctionEntity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#functionentity","content":" Description: Represents a function within an entity, detailing its name, parameters, and return type.Attributes: name: The name of the function.response: The data type of the function's return value.parameters: A collection of Parameter instances defining the function's parameters. Relationships: Has: Can contain multiple Parameter instances.  ","version":"Next","tagName":"h3"},{"title":"Parameter​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#parameter","content":" Description: Represents a parameter of a function within an entity.Attributes: elements: A collection of Element instances defining the parameter's elements. Relationships: Includes: Can contain multiple Element instances.  ","version":"Next","tagName":"h3"},{"title":"Element​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#element","content":" Description: Represents an individual element within a parameter, specifying its name and type.Attributes: name: The name of the element.type: The data type of the element.  ","version":"Next","tagName":"h3"},{"title":"Attribute​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#attribute","content":" Description: Represents an attribute of an entity, detailing its name, type, and various constraints.Attributes: name: The name of the attribute.type: The data type of the attribute.fullName: An optional string specifying the full name.unique: An optional boolean indicating if the attribute is unique.blank: An optional boolean indicating if the attribute can be blank.max: An optional integer specifying the maximum value.min: An optional integer specifying the minimum value.  ","version":"Next","tagName":"h3"},{"title":"EnumEntityAtribute​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#enumentityatribute","content":" Description: Represents an attribute of an enumeration within an entity.Attributes: name: The name of the enumeration attribute.type: A reference to an EnumX instance indicating the type of the enumeration.  ","version":"Next","tagName":"h3"},{"title":"EnumX​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#enumx-1","content":" Description: Represents an enumeration type within the system.Attributes: name: The name of the enumeration.attributes: A collection of AttributeEnum instances defining the enumeration's attributes. Relationships: Contains: Can contain multiple AttributeEnum instances.  ","version":"Next","tagName":"h3"},{"title":"AttributeEnum​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#attributeenum","content":" Description: Represents a single attribute within an enumeration.Attributes: name: The name of the enumeration value.fullName: An optional string specifying the full name of the enumeration value.  ","version":"Next","tagName":"h3"},{"title":"Relation (Abstract Class)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#relation-abstract-class","content":" Description: An abstract class representing relationships between entities. Specific types of relationships (OneToOne, OneToMany, ManyToOne, ManyToMany) inherit from this class.  OneToOne​  Description: Represents a one-to-one relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.  OneToMany​  Description: Represents a one-to-many relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.  ManyToOne​  Description: Represents a many-to-one relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.  ManyToMany​  Description: Represents a many-to-many relationship between two entities.Attributes: name: The name of the relationship.type: A reference to the related Entity.fullName: An optional string specifying the full name of the relationship.by: An optional reference to a LocalEntity that mediates the relationship.  ","version":"Next","tagName":"h3"},{"title":"QualifiedName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#qualifiedname-1","content":" Description: Represents a qualified name used to uniquely identify elements within the system. It typically follows the format ID(.ID)*, allowing for hierarchical naming.Attributes: id: A string representing the qualified name, composed of one or more identifiers separated by dots (e.g., com.example.project).  ","version":"Next","tagName":"h3"},{"title":"Comment​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#comment-1","content":" Description: Represents a comment within the grammar, providing additional context or explanations for modules or other elements.Attributes: content: A string containing the comment text.  ","version":"Next","tagName":"h3"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#usecase-1","content":" This class diagram focuses on the Actor and UseCase elements defined in your SPARK grammar. It includes related classes such as Entity, QualifiedName, and Comment to fully represent the structure and relationships within your metamodel.    ","version":"Next","tagName":"h2"},{"title":"Actor​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#actor-1","content":" Description: Represents an actor within the system, typically a user or external system that interacts with use cases.Attributes: name: A QualifiedName that uniquely identifies the actor.entity: An Entity that the actor is associated with.superType: An optional reference to another Actor that this actor extends. Relationships: Is: Each Actor is associated with one Entity.Extends: An Actor can optionally extend another Actor, establishing an inheritance relationship.  ","version":"Next","tagName":"h3"},{"title":"UseCase​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#usecase-2","content":" Description: Represents a use case within the system, defining a specific functionality or behavior that actors can perform.Attributes: name: A QualifiedName that uniquely identifies the use case.superType: An optional reference to another UseCase that this use case extends.fullName: A string representing the full name of the use case.kind: An enumeration (Kind) indicating the type of use case (manage or view).performed: A collection of Actor instances that perform this use case.models: A collection of Entity instances that are involved in this use case.extend: An optional collection of UseCase instances that this use case extends.include: An optional collection of UseCase instances that this use case includes. Relationships: Extends: A UseCase can optionally extend another UseCase, establishing an inheritance relationship.Includes: A UseCase can optionally include other UseCase instances.Performed By: A UseCase is performed by one or more Actor instances.Models: A UseCase involves one or more Entity instances.  ","version":"Next","tagName":"h3"},{"title":"Entity​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#entity-2","content":" Description: An interface implemented by various entity classes (LocalEntity, ImportedEntity, etc.). Represents any entity within the system.Attributes: None (serves as a marker interface).Relationships: Implemented By: Actor implements the Entity interface.  ","version":"Next","tagName":"h3"},{"title":"QualifiedName​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#qualifiedname-2","content":" Description: Represents a qualified name used to uniquely identify elements within the system. Typically follows the format ID(.ID)*, allowing for hierarchical naming.Attributes: id: A string representing the qualified name, composed of one or more identifiers separated by dots (e.g., com.example.project).  ","version":"Next","tagName":"h3"},{"title":"Kind (Enumeration)​","type":1,"pageTitle":"Metamodel","url":"/leds-tools-public/spark/metamodel#kind-enumeration","content":" Description: Defines the type of use case.Values: manageview ","version":"Next","tagName":"h3"},{"title":"🗂️ Comunication Plan – SPARK (Frontend)","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan","content":"","keywords":"","version":"Next"},{"title":"1. Main Goal​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan#1-main-goal","content":" Ensure clear, efficient, and continuous communication among the members of the Software Project Management, Systems Project teams, and stakeholders, promoting alignment, progress tracking, and identification of obstacles.    ","version":"Next","tagName":"h2"},{"title":"2. Participants​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan#2-participants","content":" Name\tRole\tLevel of EngagementJoão Vitor Lopes\tGPS Team Leader\tHigh João Victor Vieira\tGPS Team Member\tHigh João Pedro Pagotto\tGPS Team Member\tHigh Alex Rossoni\tGPS Team Member\tHigh Davi Breda\tGPS Team Member\tHigh Thalison Vinícius\tGPS Team Member\tHigh Murilo Dias de Oliveira\tProject Development Team Leader\tHigh Lucas Gabriel Araújo\tProject Development Team Member\tHigh Bruno Alves\tProject Development Team Member\tHigh Arthur Valentim\tProject Development Team Member\tHigh Caio chiabai de Oliveira\tProject Development Team Member\tHigh Diego Bourguignon\tProject Development Team Member\tHigh    ","version":"Next","tagName":"h2"},{"title":"3. Comunication Channels​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan#3-comunication-channels","content":" Type of Comunication\tChannel\tGoal\tParticipants\tFrequencyFast Comunication\tDiscord + Whatsapp\tIssue resolution and quick notifications + direct communication between dev and manager\tGPS and PS Teams\tEvery day Sprint Planning\tGoogle Meet or In Person + Github Projects + PMC\tTasks Planning\tGPS Team\tWeekly Weekly\tGoogle Meet or In Person\tShare status and obstacles\tGPS and PS Teams\tWeekly    ","version":"Next","tagName":"h2"},{"title":"4. Comunication Routine​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan#4-comunication-routine","content":" Event\tFormat\tDuration\tFrequency\tFacilitator\tNotesReview and Planning\tOnline Meeting or In Person\t15-30 min\tWeekly\tLeader GPS Team\tUses PMC and Github Projects to review the previous steps and plan the next ones Weekly\tOnline Meeting or In Person\t45 min - 1 hour\tWeekly\tLeaders GPS and PS Team\tOne of the members of the Project Development Team answers the questions about the Ongoing Project, and lists impediments and issues that may arise    ","version":"Next","tagName":"h2"},{"title":"5. Responsables for Comunication​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan#5-responsables-for-comunication","content":" Content Type\tLead ResponsableTechnical Status\tPS Team Planning and Backlog\tGPS Team Meeting Facilitator\tFacilitator Comunication with stakeholders\tGPS and PS Team Leaders Technical Documentation\tProject Development Team    ","version":"Next","tagName":"h2"},{"title":"6. Good Practices​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/backend_communication_plan#6-good-practices","content":" Use asynchronous communication whenever possible.Avoid long or unfocused meetings.Keep all documents updated and accessible.Maintain ongoing comunication through Discord channels for each Team.Encourage frequent feedback. ","version":"Next","tagName":"h2"},{"title":"Back-end Team Envolved","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Team Management/DISC/backend_disc","content":"","keywords":"","version":"Next"},{"title":"Team DISC Profiles​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/Team Management/DISC/backend_disc#team-disc-profiles","content":" Our team has taken the DISC assessment to identify each member's behavioral profile. This helps us better understand our strengths, working styles, and how we can collaborate more effectively.    ","version":"Next","tagName":"h2"},{"title":"Dominance (D)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/Team Management/DISC/backend_disc#dominance-d","content":" People with a Dominant profile are result-oriented, quick decision-makers, and thrive on challenges. They are great at leading initiatives and solving problems efficiently.  Caio Chiabai de Oliveira     ","version":"Next","tagName":"h3"},{"title":"Influence (I)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/Team Management/DISC/backend_disc#influence-i","content":" The Influence profile is associated with communicative, enthusiastic, and motivating individuals. They tend to inspire others and create a positive work environment.  Lucas Codeco     ","version":"Next","tagName":"h3"},{"title":"Steadiness (S)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/Team Management/DISC/backend_disc#steadiness-s","content":" People with this profile are patient, collaborative, and focused on maintaining harmony. They are reliable and consistent in their work.  Murilo Dias Arthur Valentim Caldeira Bruno Alves De Morais     ","version":"Next","tagName":"h3"},{"title":"Conscientiousness (C)​","type":1,"pageTitle":"Back-end Team Envolved","url":"/leds-tools-public/spark/Team Management/DISC/backend_disc#conscientiousness-c","content":" The Conscientiousness profile values rules, precision, and quality. These individuals are detail-oriented, analytical, and committed to technical excellence.  Diego Bourguignon Rangel  ","version":"Next","tagName":"h3"},{"title":"🗂️ Comunication Plan – SPARK (Frontend)","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan","content":"","keywords":"","version":"Next"},{"title":"1. Main Goal​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan#1-main-goal","content":" Ensure clear, efficient, and continuous communication among the members of the Software Project Management, Systems Project teams, and stakeholders, promoting alignment, progress tracking, and identification of obstacles.    ","version":"Next","tagName":"h2"},{"title":"2. Participants​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan#2-participants","content":" Name\tRole\tLevel of EngagementLarissa Rangel\tGPS Team Leader\tMuito Alto Gabriel Barbosa\tProject Planner and Facilitator\tMuito alto Lorhan de Souza\tSupport Team Member\tMédio Thiago Carvalho\tSupport Team Member\tMédio Rodolfo\tSupport Team Member\tBaixo Bruno da Fonseca Chevitarese\tPS Team Leader\tMuito Alto Henrique de Souza Lima\tSupport Team Member\tMédio Guilherme Borges Cabral\tSupport Team Member\tMuito Alto Nicolas Duarte Botelho\tSupport Team Member\tMuito Alto Lucas Bruno Alves\tSupport Team Member\tBaixo    ","version":"Next","tagName":"h2"},{"title":"3. Comunication Channels​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan#3-comunication-channels","content":" Type of Comunication\tChannel\tGoal\tParticipants\tFrequencyFast Comunication\tDiscord\tIssue resolution and quick notifications\tGPS and PS Teams\tEvery day Sprint Planning\tGoogle Meet + Github Projects + PMC\tTasks Planning\tGPS Team\tWeekly Weekly\tGoogle Meet\tShare status and obstacles\tGPS and PS Teams\tWeekly    ","version":"Next","tagName":"h2"},{"title":"4. Comunication Routine​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan#4-comunication-routine","content":" Event\tFormat\tDuration\tFrequency\tFacilitator\tNotesReview and Planning\tOnline Meeting\t30 min\tWeekly\tLeader GPS Team\tUses PMC and Github Projects to review the previous steps and plan the next ones Weekly\tOnline Meeting\t45 min\tWeekly\tLeaders GPS and PS Team\tOne of the members of the Systems Project Team answer the questions about the Ongoing Project    ","version":"Next","tagName":"h2"},{"title":"5. Responsables for Comunication​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan#5-responsables-for-comunication","content":" Content Type\tLead ResponsableTechnical Status\tPS Team Planning and Backlog\tGPS Team Meeting Facilitator\tFacilitator Comunication with stakeholders\tGPS and PS Team Leaders Technical Documentation\tSupport Team Members    ","version":"Next","tagName":"h2"},{"title":"6. Good Practices​","type":1,"pageTitle":"🗂️ Comunication Plan – SPARK (Frontend)","url":"/leds-tools-public/spark/Team Management/Communication Plan/frontend_communication_plan#6-good-practices","content":" Use asynchronous communication whenever possible.Avoid long or unfocused meetings.Keep all documents updated and accessible.Maintain ongoing comunication through Discord channels for each Team.Encourage frequent feedback. ","version":"Next","tagName":"h2"},{"title":"Team Member's DISC Personality","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Team Management/DISC/frontend_disc","content":"","keywords":"","version":"Next"},{"title":"1. Main Goal​","type":1,"pageTitle":"Team Member's DISC Personality","url":"/leds-tools-public/spark/Team Management/DISC/frontend_disc#1-main-goal","content":" Understand the pesonality of each member related to SPARK - Frontend Project and how the members of the teams can collaborate better to the development of the project.  ","version":"Next","tagName":"h2"},{"title":"2. DISC Tests Team GPS​","type":1,"pageTitle":"Team Member's DISC Personality","url":"/leds-tools-public/spark/Team Management/DISC/frontend_disc#2-disc-tests-team-gps","content":" Name\tDominance\tInfluence\tSteadliness\tConscientiounessLarissa Rangel\t12,50%\t45,00%\t35%\t7,50% Gabriel Barbosa\t7.32%\t19.51%\t58.78%\t24.39% Lorhan de Souza\t0%\t12.50%\t57.50%\t30% Thiago Carvalho\t20%\t52%\t15%\t12% Rodolfo\t-----------\t-----------\t-------------\t------------------  ","version":"Next","tagName":"h2"},{"title":"3.DISC Tests Team PS​","type":1,"pageTitle":"Team Member's DISC Personality","url":"/leds-tools-public/spark/Team Management/DISC/frontend_disc#3disc-tests-team-ps","content":" Name\tDominance\tInfluence\tSteadliness\tConscientiounessBruno Chevitarese\t37.50%\t7.50%\t22.50%\t32.50% Henrique de Souza Lima\t17.50%\t5%\t47.50%\t30% Guilherme Borges Cabral\t7%\t7%\t27%\t57% Nicolas Duarte Botelho\t20%\t12.50%\t25%\t42.50% Lucas Bruno Alves\t22.50%\t30%\t27.50%\t20% ","version":"Next","tagName":"h2"},{"title":"Front-end Team Topology","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology","content":"","keywords":"","version":"Next"},{"title":"👥 Team Topology – SPARK​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology#-team-topology--spark","content":" ","version":"Next","tagName":"h2"},{"title":"📦 Team: Frontend (Responsible Group)​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology#-team-frontend-responsible-group","content":" Type: Stream-aligned team Mission: Develop a modern, understandable, and accessible interface for SPARK using Vue.js and Tailwind, enabling better user interaction with the platform. Main Deliverables: Interface built with Vue 3 + TailwindCSSGraphical and interactive visualization of entities and relationshipsIntegration with .spark filesInformative dashboardsClear frontend usage documentation Main Technologies: Vue.js 3TailwindCSSViteGitHub    ","version":"Next","tagName":"h3"},{"title":"🛠️ Collaborating Team: Backend​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology#️-collaborating-team-backend","content":" Type: Enabling teamRole: Provide technical support to the frontend team regarding the structure and rules of .spark files, data validation, and communication with generated services.    ","version":"Next","tagName":"h3"},{"title":"📚 Documentation​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology#-documentation","content":" Documentation hosted on DocusaurusDocumentation structure: Project overviewTechnologies usedDISC profiles of team membersBacklogCommunication PlanTeam Topology    ","version":"Next","tagName":"h3"},{"title":"🔄 Collaboration Format​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology#-collaboration-format","content":" Weekly summaries: Every week, each group posts a summary of what was done, pending tasks, and next steps.Group reviews: Whenever a stage is completed, a collective review will be conducted (async or via call).    ","version":"Next","tagName":"h3"},{"title":"💬 Communication​","type":1,"pageTitle":"Front-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/frontend_teamtopology#-communication","content":" Main channel: Discord (dedicated channel per team)Quick support: WhatsAppTask management: ","version":"Next","tagName":"h3"},{"title":"Gerencia de Processos de Software","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/project_management_front","content":"","keywords":"","version":"Next"},{"title":"Project Model Canvas​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#project-model-canvas","content":"   ","version":"Next","tagName":"h2"},{"title":"DISC​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#disc","content":" ","version":"Next","tagName":"h2"},{"title":"Gerência de Processo de Software​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#gerência-de-processo-de-software","content":" Integrante\tResultadoEduardo Pitanga Loureiro\tEstabilidade Gabriel Davel\tConformidade Theo Gomes\tConformidade Daniel Henrique\tConformidade Lorenzo\tEstabilidade    ","version":"Next","tagName":"h3"},{"title":"Projeto de Sistemas​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#projeto-de-sistemas","content":" Integrante\tResultadoGabriel Lacerda\tEstabilidade Ryan\tConformidade Davi Alvarenga\tConformidade Gato preto\tEstabilidade    Eduardo Pitanga Loureiro​  Resultado: Estabilidade     Gabriel Davel​  Resultado: Conformidade     Daniel Henrique​  Resultado: Conformidade     Gabriel Lacerda​  Resultado: Estabilidade     Ryan​  Resultado: Conformidade     Davi Alvarenga​  Resultado: Conformidade     Gato preto​  Resultado: Estabilidade     Theo Gomes​  Resultado: Conformidade     Lorenzo​  Resultado: Estabilidade     ","version":"Next","tagName":"h3"},{"title":"Backlog​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#backlog","content":" Backlog atualizado no Github  ID\tTask\tType\tPriority\tNotes01\tValidate generation of .feature (Gherkin) files from .andes\tValidation\tHigh\tTest if the “Generate BDD feature” button works as expected 02\tTest generation of Cypress tests from .vue files\tValidation\tHigh\tCheck if the generated tests make sense and are saved correctly 03\tCreate step-by-step documentation with screenshots of frontend features\tDocumentation\tHigh\tCan be in Markdown or Wiki, with prerequisites and usage examples 04\tReview usage of data-test in .vue components and suggest a consistent pattern\tAnalysis/Improvement\tMedium\tHelps ensure quality in Cypress test generation 05\tRun generated Cypress tests to validate proper execution\tTesting\tHigh\tEnsure the tests actually validate the UI as expected 06\tCreate a basic tutorial in the README for using main frontend functionalities\tDocumentation\tMedium\tHelpful for onboarding new developers or testers  ","version":"Next","tagName":"h2"},{"title":"Design Structure Matrix (DSM)​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#design-structure-matrix-dsm","content":" Tarefa ↓ que depende\t01 - Validate generation of .feature\t02 - Test generation of Cypress tests\t03 - Create step-by-step documentation\t04 - Review usage of data-test in .vue\t05 - Run generated Cypress tests\t06 - Create a basic tutorial in the README01 - Validate generation of .feature 02 - Test generation of Cypress tests 03 - Create step-by-step documentation\tX\tX 04 - Review usage of data-test in .vue 05 - Run generated Cypress tests\tX\tX 06 - Create a basic tutorial in the README\tX\tX\tX\tX\tX\t  ","version":"Next","tagName":"h2"},{"title":"Plano de Comunicação​","type":1,"pageTitle":"Gerencia de Processos de Software","url":"/leds-tools-public/test_ai/project_management_front#plano-de-comunicação","content":" Canal no Discord ","version":"Next","tagName":"h2"},{"title":"Back-end Team Topology","type":0,"sectionRef":"#","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology","content":"","keywords":"","version":"Next"},{"title":"👥 Team Topology – SPARK​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology#-team-topology--spark","content":" ","version":"Next","tagName":"h2"},{"title":"📦 Team: Backend (Responsible Group)​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology#-team-backend-responsible-group","content":" Type: Stream-aligned team Mission: Build the core services and API of SPARK using Python, Java, and .NET, enabling the platform to interact with the front-end and process the generated .spark files. Main Deliverables: REST APIs built with Django (Python), Spring Boot (Java), and .NET (Minimal API or Clean Architecture with CQRS)Data validation and processingIntegration with the front-end through clear API endpointsBackend usage documentation and API referenceScalable and maintainable codebase Main Technologies: Python (Django)Java (Spring Boot).NET (Minimal API or Clean Architecture with CQRS)PostgreSQL (or any other DB technology)GitHub    ","version":"Next","tagName":"h3"},{"title":"🛠️ Collaborating Team: Frontend​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology#️-collaborating-team-frontend","content":" Type: Enabling teamRole: Provide support to the back-end team by defining clear API specifications, assisting in data validation, and ensuring smooth integration with the front-end via API endpoints.    ","version":"Next","tagName":"h3"},{"title":"📚 Documentation​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology#-documentation","content":" Documentation hosted on DocusaurusDocumentation structure: Project overviewTechnologies usedDISC profiles of team membersBacklogCommunication PlanTeam Topology    ","version":"Next","tagName":"h3"},{"title":"🔄 Collaboration Format​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology#-collaboration-format","content":" Weekly summaries: Each team provides updates on what has been accomplished, what is pending, and the upcoming tasks for the week.Group reviews: Reviews are conducted whenever major milestones are reached, either asynchronously or through video calls.    ","version":"Next","tagName":"h3"},{"title":"💬 Communication​","type":1,"pageTitle":"Back-end Team Topology","url":"/leds-tools-public/spark/Team Management/Team Topology/backend_teamtopology#-communication","content":" Main channel: Discord (dedicated channel per team)Quick support: WhatsApp/DiscordTask management: GitHub Issues/Kanban for sprint management ","version":"Next","tagName":"h3"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/project_managment","content":"","keywords":"","version":"Next"},{"title":"Backlog​","type":1,"pageTitle":"Project Management","url":"/leds-tools-public/test_ai/project_managment#backlog","content":" ID\tFeature\tDescription\tImportance\tProposal1\tCreate E2E tests using Use Case`s description\tCreate BDD files from Use Case description, Non-Functional Requirements, and Business rules\t100\tImprove software developmen productivity in 10% 2\tCreate Code to automate the E2E tests Back-End\tCreate coding file that implements E2E Testing to Back-end.\t90\tImprove software developmen productivity in 10% 3\tCreate Code to automate the E2E tests Front-End\tCreate coding file that implements E2E Testing to Fron-End.\t80\tImprove software developmen productivity in 10% ","version":"Next","tagName":"h2"},{"title":"Tutorial de Instalação e Configuração do Test.AI","type":0,"sectionRef":"#","url":"/leds-tools-public/test_ai/testai","content":"","keywords":"","version":"Next"},{"title":"Pré-requisitos​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#pré-requisitos","content":" Antes de começar, verifique se você já tem o seguinte instalado em sua máquina:  Python (incluindo o gerenciador de pacotes pip)Visual Studio CodeNode.js (recomendado)    ","version":"Next","tagName":"h2"},{"title":"Passo 1: Instalar a Biblioteca Python​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-1-instalar-a-biblioteca-python","content":" Abra um terminal em sua máquina.Execute o seguinte comando para instalar a biblioteca:  pip install test-ai-leds   Após a instalação, certifique-se de que o diretório Scripts do Python foi adicionado à variável de ambiente PATH. Windows: Execute no terminal pip show test-ai-ledsAlgumas informações serão retornadas e entre elas estará a localização dos pacotes instalados. Será algo como:C:\\Users\\user\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python312\\site-packagesBasta alterar o último diretório de site-packages para Scripts. Exemplo:C:\\Users\\user\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python312\\ScriptsAdicione esse caminho nas variáveis de ambienteNota: O mesmo pode ser feito utilizando virtual enviroments do python caso não queira instalar a biblioteca globalmente. Nesse caso o caminho dos Scripts será relativo a pasta da venv.  Linux: Linux não permite instalações globais de pacotes python. Portanto é preciso criar um virtual enviroment com o comando: python -m venv &lt;nome da venv&gt;Ative a venv com source &lt;caminho da venv&gt;/bin/activateExecute pip install test-ai-ledsO caminho dos Scripts em linux geralmente é &lt;caminho da venv/binExecute nano ~/.bashrc e adicione no final do arquivo export PATH=$PATH:/&lt;caminho da sua venv&gt;/binExecute source ~/.bashrc para efetivar as alterações    ","version":"Next","tagName":"h2"},{"title":"Passo 2: Instalar a Extensão Test.AI no Visual Studio Code​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-2-instalar-a-extensão-testai-no-visual-studio-code","content":" Abra o Visual Studio Code.Vá até a aba de extensões clicando no ícone de &quot;Extensions&quot; no lado esquerdo (ou use o atalho Ctrl+Shift+X).Na barra de pesquisa, digite Test.AI.Encontre a extensão Test.AI e clique em Install para instalá-la.    ","version":"Next","tagName":"h2"},{"title":"Passo 3: Configurar o Arquivo .env do Projeto​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-3-configurar-o-arquivo-env-do-projeto","content":" No projeto aberto no Visual Studio Code, crie (ou edite) um arquivo chamado .env na raiz do repositório.Adicione as seguintes configurações ao arquivo:  LLM_MODEL=&lt;um modelo de LLM que você queira usar&gt; API_KEY=&lt;sua chave de API para o modelo LLM escolhido&gt; SWAGGER_PATH=&lt;caminho completo para o documento Swagger referente ao projeto&gt; DTO_SOURCE=&lt;caminho completo para a pasta onde os DTOs do projeto estão&gt;   ","version":"Next","tagName":"h2"},{"title":"Modelo Padrão​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#modelo-padrão","content":" Por padrão, é recomendado o uso do modelo Gemini, que possui uma API gratuita. Você pode gerar sua chave de API através deste link. Defina o LLM_MODEL no seu .env como &quot;gemini/gemini-1.5-flash&quot;  ","version":"Next","tagName":"h3"},{"title":"Exemplo​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#exemplo","content":" LLM_MODEL=gemini/gemini-1.5-flash API_KEY=abc123def456 SWAGGER_PATH=C:/Users/SeuUsuario/Projeto/swagger.json DTO_SOURCE=C:/Users/SeuUsuario/Projeto/DTOs   Salve o arquivo .env.    ","version":"Next","tagName":"h3"},{"title":"Dica: Verificar as Dependências do Node.js (Opcional)​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#dica-verificar-as-dependências-do-nodejs-opcional","content":" Embora não seja obrigatório, recomenda-se ter o Node.js instalado para garantir que todas as ferramentas e dependências sejam executadas sem problemas. Você pode verificar se o Node.js está instalado executando:  node -v   Se o comando retornar a versão do Node.js, significa que ele já está instalado.  Caso contrário, você pode baixá-lo e instalá-lo a partir do site oficial: Node.js Downloads    ","version":"Next","tagName":"h2"},{"title":"Finalização​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#finalização","content":" Após seguir esses passos, a biblioteca Python test-ai-leds e a extensão Test.AI devem estar configuradas e prontas para uso. Certifique-se de verificar as variáveis no arquivo .env e garantir que o diretório Scripts do python esteja salvo no PATH.    Como Usar  ","version":"Next","tagName":"h2"},{"title":"Funcionalidade 1: Gerar Arquivos de Código Gherkin (Features, BDD)​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#funcionalidade-1-gerar-arquivos-de-código-gherkin-features-bdd","content":" ","version":"Next","tagName":"h2"},{"title":"Pré-requisito​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#pré-requisito","content":" Um documento de requisito no formato .andes  ","version":"Next","tagName":"h3"},{"title":"Passo a Passo​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-a-passo","content":" Abra o documento .andes no Visual Studio Code.Clique com o botão direito no editor de texto.No menu de contexto, selecione a opção &quot;Generate BDD feature&quot;.A ferramenta gerará automaticamente os arquivos Gherkin (.feature) e salvará os arquivos em uma pasta chamada features. Caso a pasta features ainda não exista na raiz do projeto, ela será criada automaticamente.    ","version":"Next","tagName":"h3"},{"title":"Funcionalidade 2: Gerar Steps das Features (C# com xUnit)​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#funcionalidade-2-gerar-steps-das-features-c-com-xunit","content":" ","version":"Next","tagName":"h2"},{"title":"Pré-requisito​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#pré-requisito-1","content":" Um arquivo Gherkin (.feature) gerado pela funcionalidade anterior ou adicionado manualmente.  ","version":"Next","tagName":"h3"},{"title":"Passo a Passo​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-a-passo-1","content":" Abra o arquivo .feature no Visual Studio Code.Clique com o botão direito no editor de texto.Escolha uma das seguintes opções no menu de contexto: &quot;Generate for this feature&quot;: Gera os steps relacionados apenas à feature aberta no momento.&quot;Generate for all features&quot;: Gera os steps para todas as features contidas na pasta features. Os steps serão salvos em arquivos C# na pasta steps. Caso a pasta steps ainda não exista na raiz do projeto, ela será criada automaticamente.    ","version":"Next","tagName":"h3"},{"title":"Funcionalidade 3: Gerar teste Black-Box em Cypress​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#funcionalidade-3-gerar-teste-black-box-em-cypress","content":" ","version":"Next","tagName":"h2"},{"title":"Pré-requisito​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#pré-requisito-2","content":" Um arquivo Vue (.vue)Preferencialmente elementos com atributo data-test.  ","version":"Next","tagName":"h3"},{"title":"Passo a Passo​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-a-passo-2","content":" Abra o arquivo vue no Visual Studio Code.Clique com o botão direito no editor de texto.Escolha a seguinte opção: &quot;Generate cypress black box test&quot;Os arquivos cypress serão salvos na pasta cypress  ","version":"Next","tagName":"h3"},{"title":"Funcionalidade 4: Gerar teste unitários em C#​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#funcionalidade-4-gerar-teste-unitários-em-c","content":" ","version":"Next","tagName":"h2"},{"title":"Pré-requisito​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#pré-requisito-3","content":" Um arquivo C# (.cs)O arquivo deve pertencer ao projeto do ConectaFapes para ser gerado corretamente  ","version":"Next","tagName":"h3"},{"title":"Passo a Passo​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#passo-a-passo-3","content":" Abra o arquivo .cs no Visual Studio Code.Clique com o botão direito no editor de texto.Escolha a seguinte opção: &quot;Generate unit test for this file&quot;Os arquivos serão salvos na pasta unit    ","version":"Next","tagName":"h3"},{"title":"Observação​","type":1,"pageTitle":"Tutorial de Instalação e Configuração do Test.AI","url":"/leds-tools-public/test_ai/testai#observação","content":" Todas as pastas onde os arquivos são salvos serão criadas caso não ainda não exista ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}