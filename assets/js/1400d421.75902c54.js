"use strict";(self.webpackChunkdocumentacao_leds_tools=self.webpackChunkdocumentacao_leds_tools||[]).push([[5407],{430:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var n=r(4848),a=r(8453);const o={sidebar_position:1,title:"Creational Patterns"},s="Factory Method Pattern in the Project Structure",c={id:"spark/Creational-Patterns/Factory-Method",title:"Creational Patterns",description:"We used the Factory Method design pattern to organize and structure the generation of different parts of the system. The main idea was to create a modular and reusable way to generate files based on a common model, keeping the code organized, flexible, and easy to understand.",source:"@site/docs/spark/Creational-Patterns/1_Factory-Method.md",sourceDirName:"spark/Creational-Patterns",slug:"/spark/Creational-Patterns/Factory-Method",permalink:"/leds-tools-public/spark/Creational-Patterns/Factory-Method",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Creational Patterns"},sidebar:"spark",previous:{title:"Vue Plus Vuetfy",permalink:"/leds-tools-public/spark/Architecture/Understanding the Generated Code Architecture/frontend/vuePlusVuetfy"},next:{title:"Overview",permalink:"/leds-tools-public/spark/Lib/OverView"}},i={},d=[{value:"Structure I Implemented",id:"structure-i-implemented",level:2},{value:"1. Abstract Class: <code>AbstractGeneratorFactory</code>",id:"1-abstract-class-abstractgeneratorfactory",level:3},{value:"2. Factory Method: <code>createGenerators()</code>",id:"2-factory-method-creategenerators",level:3},{value:"3. Common Interface: <code>IJavaGenerator</code>",id:"3-common-interface-ijavagenerator",level:3},{value:"4. Concrete Generators",id:"4-concrete-generators",level:3}];function l(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"factory-method-pattern-in-the-project-structure",children:"Factory Method Pattern in the Project Structure"})}),"\n",(0,n.jsxs)(t.p,{children:["We used the ",(0,n.jsx)(t.strong,{children:"Factory Method design pattern"})," to organize and structure the generation of different parts of the system. The main idea was to create a ",(0,n.jsx)(t.strong,{children:"modular and reusable"})," way to generate files based on a common model, keeping the code organized, flexible, and easy to understand."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"structure-i-implemented",children:"Structure I Implemented"}),"\n",(0,n.jsx)(t.p,{children:"The structure is composed of 4 main parts:"}),"\n",(0,n.jsxs)(t.h3,{id:"1-abstract-class-abstractgeneratorfactory",children:["1. Abstract Class: ",(0,n.jsx)(t.code,{children:"AbstractGeneratorFactory"})]}),"\n",(0,n.jsxs)(t.p,{children:["I created a base class called ",(0,n.jsx)(t.code,{children:"AbstractDocumentationGeneratorFactory"}),", which defines a method ",(0,n.jsx)(t.code,{children:"generate()"}),". This method:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Creates the folder where the files will be generated."}),"\n",(0,n.jsxs)(t.li,{children:["Calls an abstract method called ",(0,n.jsx)(t.code,{children:"createGenerators()"})," \u2014 which is the ",(0,n.jsx)(t.strong,{children:"actual factory method"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["Then, executes the ",(0,n.jsx)(t.code,{children:"generate()"})," method of each returned generator."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["This ",(0,n.jsx)(t.code,{children:"generate()"})," method controls the ",(0,n.jsx)(t.strong,{children:"common generation flow"}),", and I didn\u2019t have to repeat this logic for each generator type."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.h3,{id:"2-factory-method-creategenerators",children:["2. Factory Method: ",(0,n.jsx)(t.code,{children:"createGenerators()"})]}),"\n",(0,n.jsxs)(t.p,{children:["This method is abstract and implemented by the subclasses.",(0,n.jsx)(t.br,{}),"\n",'Each subclass represents a specific "factory", such as:']}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"StandardDocumentationGeneratorFactory"})," \u2013 responsible for generating documentation files."]}),"\n",(0,n.jsx)(t.li,{children:"In other parts of the project, I have factories that generate entities or webservices as well."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Each factory knows ",(0,n.jsx)(t.strong,{children:"which concrete generators"})," it needs to instantiate."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.h3,{id:"3-common-interface-ijavagenerator",children:["3. Common Interface: ",(0,n.jsx)(t.code,{children:"IJavaGenerator"})]}),"\n",(0,n.jsxs)(t.p,{children:["All my concrete generators implement the ",(0,n.jsx)(t.code,{children:"IJavaGenerator"})," interface, which requires them to have a ",(0,n.jsx)(t.code,{children:"generate(model, targetFolder)"})," method. This ensures that any generator, regardless of what it produces, can be used interchangeably."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h3,{id:"4-concrete-generators",children:"4. Concrete Generators"}),"\n",(0,n.jsxs)(t.p,{children:["I have several concrete classes that handle the actual file generation.",(0,n.jsx)(t.br,{}),"\n","One example is ",(0,n.jsx)(t.code,{children:"DocumentationGenerator"}),", which creates files like ",(0,n.jsx)(t.code,{children:"README.md"})," and ",(0,n.jsx)(t.code,{children:".gitlab-ci.yml"}),".",(0,n.jsx)(t.br,{}),"\n","But I also have generators like ",(0,n.jsx)(t.code,{children:"EntityGenerator"}),", ",(0,n.jsx)(t.code,{children:"ControllerGenerator"}),", among others."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>c});var n=r(6540);const a={},o=n.createContext(a);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);